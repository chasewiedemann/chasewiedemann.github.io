---
title: "Mini-Blog"
output: html_document
---

```{r,echo = F}
base_dir = getwd()
base_url = paste0("https://",substr(base_dir,8, nchar(base_dir)))
sum_link = paste0(base_url,"/Summary.html")
miniblog_link = paste0(base_url,"/MiniBlog.html")
```

[Home](https://chasewiedemann.github.io/index.html) |
[About](https://chasewiedemann.github.io/Site/about.html) |
[Projects](https://chasewiedemann.github.io/Site/Projects/projects.html) |
[Blog](https://chasewiedemann.github.io/Site/blog.html) |



# Plan
This is a big paper. I want to first go through the authors companion paper which does the math separately from the rest, then get into the main ECMA paper

# KLR 2024: The Linear Algebra of Economic Geography Models

## Initial Reading Notes

- the world economy consists of a set of location index by $i \in \{0,\dots ,N\}$
- The economy has an exogenous supply of workers that is normalized to one $\overline l = 1$
- Each worker gets one unit of labor that is supplied inelastically. 
- Workers are perfectly mobile across location, but have idiosyncratic preferences for each location
### Consumer preference
- Every worker $v$ in location $n$ has the indirect utility function $u_n(\nu) = \frac{b_n\epsilon_n(\nu)w_n}{p_n}$
  + $w_n$ is the wage 
  + $p_n$ is the price index of the consumption good
  + $b_n$ are the amenities that are common for all workers
  + $\epsilon(\nu)$ is a idosyncratic amenities preference draw that is specific to each worker $\nu$ and location $n$
- The price index is of the form $p_n = \left(\sum_{i=1}^N p_{ni}^{1-\sigma})\right)^{1/1-\sigma},\sigma>1$
- The idiosyncratic amenities draw are independent for each worker and location from the forllowing distribution $F(\epsilon) = exp(-\epsilon^{-\kappa}), \kappa >1$
  + The scale is normalized to one, as it is isomorphic to $b_n$ (the common amenities of location $n$)
  + $\kappa$ regulates dispersion of idiosyncratic amenities, which in tern determine migration elasticity, ie how responsive the population share of each location is to real wages $w_n$
### Production Technology
- Goods are produced with labor according to a constant returns technology and under the conditions of perfect competition
- Iceberg variable costs of trade: $\tau_{ni}$ must be shipped from $i$ to $n$ in order for one unit to arrive
- Cost to consumer in $n$ of purchasing the good produced in $i$ is $p_{ni} = \frac{\tau_{ni}w_i}{z_i}$
  + $z_i$ is the productivity in location $i$
  + Prodctivity on the shippers end decreases price at the recievers end
  + $z_i$ is exogenous, but apparently easy to endogenize with agglomeration economies that let productivity in each location increase with its own population of the population of immediate neighbors
### General Equilibrium
- GE is referenced by the vectors of wages and population shares in each location $\{\vec w, \vec l\}$ ($2\times N$ Matrix)
- Conviniently, we get $2\times N$ equilbrium conditions from the goods market clearning and population mobility.
- Goods market clearing
  + Income in each location equals expenditure on the good produced in that location $w_il_i = \sum_{n=1}^N s_{ni}w_nl_n$
  + $s_ni$ is the share of expenditure of importer $n$ on exporter $i$ 
  + From the CES Demand and the Production technology we get $s_{ni} = \frac{[(\tau_{ni}w_i)/z_i]^{-\theta}}{\sum_{m=1}^N [(\tau_{nm}w_m)/z_m]^{-\theta}}$
  + $\theta \equiv \sigma-1$ and is the trade elasticity
  + We then normalize the income of all location to 1: $\sum_{i=1}^N w_il_i =1$
  + The choice of distribution for $\epsilon$ gives us the probability a worker chooses to live in location $n$, and there for the number of workers in location $n$ as $l_n = \frac{(b_nw_n/p_n)^\kappa}{\sum_{h=1}^N (b_hw_h/p_h)^\kappa}$
  + Expected utility then must be the same across all locations and is given by $\overline u = \Gamma(\frac{\kappa -1}{\kappa})\left[\sum_{h=1}^N (b_hw_h/p_h)^\kappa \right]^{1/\kappa}$
  + Not normalize, endogenous in the model
### Some intuition
- Each locaion faces an upward slipping supply function for workers
  + locations have to offer a higher real wage relative to other location in order to attract a larger share of the population
- Locations that offer higher real wages attract workers with lower realization for idiosyncratic amenities
  + in english that means... Pittsburg (bad amenities) has to pay more?
- The frechet distribution allows for the wage to be exactly offset b the composition effect of lower average amenities
  + I hate this assumption, San Fran has the highest amenities and the highest wages
- Along with the exogenous productivity assumption, the dispersion force from worker idiosyncratic preferences ensures the existance of a unique eq distribution of wages and population shares across locations.
### Freind-Enemy Exposure Measures
- going to consider small productivity shocks, holding constant amenities $dlog b_i =0$, bilateral trad costs $dlog\tau_{n} =0$ amd the total population of the economy $dlog \overline l =0$
- Totally differntiate the goods market clearning codition, $w_il_i = \sum s_{ni}l_iw_i$ to yield $d logw + dlog l = T(dlog w +d logl) + \theta(TS-I)(dlog w - dlog z))$
  + S is a matrix of $s_{ni}$, the share of importer $n$'s expenditure on exporter $i$
  + T is a matrix with $T_{in} = S_{ni}\cdot \frac{w_nl_n}{w_il_i}$, exporter $i$'s income from inporter $n$
- Chanes in the total income of a location of the left hand of this equation (including both change in wages and change in popilaion) depend on a market size effect (first term on the right hand side) and a cross-substiution effect (second term on the right hand side)
- Market-size effect capture the fact that an increaes in the income of market $n$ on the right hand side increase the income of location $i$ on the left hand side by and amount that is determined b the share of location $i$ income from market $n$ given by $T{in}$
- The cross substitution effect depends on the product of the income and expendtireue share martixes $TS-I$
  + for $i\neq n$ the sum $\sum_{h=1}^N t_{ih}s_{hn}$ captures the overall competitive exposer of location $i$ to location $n$ through each of their common markets $h$ weighted by the importance of market $h$ for country $i$'s income ($t_{ih}$)
  + As competitiveness of location $n$ increases, as measured by a decline in its wage relative to its productiveity ($dlogwn - dlogz_n$) consumers in all makerts $j$ substitute towards location $n$ and awa from other locations $i\neq n$
  + What does wage being equal to prductivity tell us?
  + This substitution effect reduces income in location $i$ and reaises it in location $n$ 
  + The CES import demand sstem imposes that the magnitude of this cross-substitution efect in market $h$ depends on the trade elasticity $\theta$ and the share of expenditure in market $h$ on the goods prodced in location $n$
  + this means that consumers in market $h$ increase the expenditure share on county $n$ by $10s_{hn} and lower the expendtire share on county $i$ by $s_{hn}$ This is just logit. They have rediscovered logit. 
- Now was are going to totally differentiate the location choice probabilities $l_n = \frac{(b_nw_n/p_n)^\kappa}{\sum_{h=1}^N (b_hw_h/p_h)^\kappa}$ and get $dlog l = \kappa(I-1l')[dlog w - S(dlog w- dlogz)]$
- The ppulation share of a location is increasing in its wage.
- the population share is decreasing in its price index.
- Now we are going to totally differentiate expected utility $\overline u = \Gamma(\frac{\kappa -1}{\kappa})\left[\sum_{h=1}^N (b_hw_h/p_h)^\kappa \right]^{1/\kappa}$ to get $d log \overline u = l' [d log w - S(dlog w - dlog z)]$
- So now if we shock one of these equations, its gonna ripple through the others
  + We might shock the producitivity, which would then change the distribution of wages, which would change the population share, which changes the income, which of course then gets fed back into wages through the market size effect. 
- We are now going to link the equations by using the income normalization and rewriting the goods market clearing condition as $I+Q)(dlog w + d log l) = T(d log w + dlog l) + \theta(TS-I)(dlog w - dlog z)$
  + $Q$ is a $N\times N$ matrix with the nominal income row vector $q'$ stacked $N$ times and because of our normalization, we have $Q(dlog w +dlog l) = 0$
  + A root we can find
- We can then substitue the changes in population shares into the goods market clearing and using the common level of expected utilit , we obtain the flosed for expresion for the elasticity of wages in each location with respect to productivity shocks in all loaction $d log w = W dlog z$ 
  + $W$ is the friend-enemy matrix of bilarter wage exposure to productivity shocks
  + $W = -(91+\kappa)I- \kappa1l' - V)^{-1}V$
  + $V = \kappa(I-1l') + (I-T+Q)^{-1}\theta(TS-I)

## Thoughts after the first reading
Is this logit? The restricted substitution patterns make it seem so. I don't think that my summary of the KLR 2023 needs this, but I imagine that the math is going to be helpful. In the worst case, I've seen their notation now and will hopefully be a bit faster in the main paper.

# KLR 2023
lets go

- centeral question: understand the response of the patial distribution of economic activety to fundamental shocks, such as changes in productivity. (thats a counterfactual)
- responce to shocks is graduaal beacuse migration friction cause the tiebout hypotheiss to move slow, and capital takes time to build
- challenge: forward looking capital investments with population mobility
- investment and migration decisions in each location depend on one another, and decisions in all locations in all future time periods. (giant state space)
- They are going to give us a tractable framework for incorportating foward-looking investment into dynamic descrete choice migration model that tackles the issue of a giant state space
- Second, through linearization, they obtain closed form solutions for the economies transition path in terms of an impact matrix that captures the initial impact of shocks and a transition matrix that governs the updating of state-variarbles.
- They show that the repsonce of the economy to any shock tofundaments can be characterized in terms of the eigenvalues and vector of the transition matrix.
- With this they are able to show that capital accumulation and migration dynamics play a centreal role in the observed decline in the rate of income convergence accros US states and the persistent and heterogenous impact of shocks.
- To show their new stuff, they use standard and simple models from the literature
  + Single sector Armington (1969) model of trade with constant elasticity gravity equation fro trade
  + constant elasticity dynamic discrete choice model of migration from CAliendo, Dvorkin, \& PArro (2019), which gives us a constant elasticity gravity equation for migration
  + textbook macro specification for capital accumulation where agents choose consumption and investment to maximize intertemporal utility subject to an intertemporal budget constraint
  + The main simplifying assumption is to draw a distriction between workers and landlords, like Moll (2014), where morkers make forward-looking migration decisions, but do not have access to an investment technology and live "hand to mouth". LAndlords are geographically immobile, but have access to an investment technology in local capital such as buildings and structures, and make forward looking capital accumulation decisions with respect to that capital
- the model allows for many locations that differ in productive and amenities, and a rich geography of bilateral trade and migration costs.
- They are going to show how to derive analytical conditions for the existence and uniqueness of equilibirum
- The eq only relys on the structural parameters such as agglomeration and dispersion forces which are invarient with respect to the initial conditions.
- The exact-hat algebra can let us take any point on the trasition path, change the the fundamentals, and then solve for the counterfactual transition path.
- Linearizing the model gives us a closed form solution for the eoncomies transtion path in terms of the impact and transition matrices. These matrices depend solely on trade and migration shares that are observed in the data and the structural paramters
- Eigendecompostion of the transition matrix shows that the dynamic responce of the state variables to any empiralcal shock to productivity and amenities can be expressed as a linear combination of its response to what they call eigenshocks
  + shocks to the fundamentals for which the initial impact on the capital and labor state vairavles correspons to an eigenvector of the transition matrix. 
- Eigenshocks have three key properties
  + computable from the observed data
  + speed of convergence to steady state for an eigen shock depends solely on the associated eigen value, allowing for sharp characterization of the determinates of speed of convergecne
  + we can revoer loadings of any empirical shock to fundamentals on these eigenshocks from a linear projection of the empirical schocks on the eigenshocks, which allows them to use the framework to understand the impact of epmirical shocks.
- They apply their framework to the determinants of income convergence across US states from 1965 to 2015. 
- The tractablity of their approach allows for a large number of extensions and generalizations including agglomeration forces in production and residential decsiion. They show that the model works for a large class of trade and interal competition models.
- Who do they cite?
  + Economic Geography - Krugman 1991 and Fujita, Krugma and Venables 1999
  + dynamic discrete choice models of migration: artuc, chaduhuri and mcLaren 2010, Caliendo and Parro 2020, allen donalson 2022, but the big one is above
  + dyanmic models of capital accumulation: Aderson, Larch, Yotov 2015, Eaton Kortum Neiman and Romalis 2016, Alverex 2017, ravikumar, santacreu and sposi 2019

## The model
- $N$ Locations indexed by $i$
- Discrete time indexed by $t$. 
- Two types of infinitely lived agents
  + workers
  + landlords
- Workers are endowed with one unit of labor that is supplied inelastically and are geographically mobile subject to migration costs. Wroders do not ahve access to any investmetn technology, so they live hand to mouth as in Kaplan Violante (2014)
- Landlords are geographically immoble and own the capital stock in their location. 
- They make forward lookign decsiions over consumption and investment in this local stock of capital. 
  + We should be thinking of this capital as buildigns and strucures that are geographically immobile once installed and depreciate at a constant rate $\delta$
- The endogenous state variables are the population and capital stock in each location. 
- the key location characteeristics that determine the spatial distribution of economic activity are the sequences of productivity $z_{it}$, amenities $b_{it}$, bilateral trade costs $\tau_{nit}$, and bilateral migration costs $\kappa_{nit}$. 
- We normalize the total population across all location to be equal to 1 in each period. This allows us to take $l_{it}$ as a population market share

### Production
- at the begining of each period $t$, the economy inherits in each location $i$ a mass of workers $l_it$ and a capital stock $k_it$. 
- firms in each location use labor and capital to produce out put $y_{it}$ of the variety supplied by that location. 
- Production is assumed to occur under conditions of perfect competition and subject constant returns to scale technology
$$ y_{it} = z_{it}(\frac{l_{it}}{\mu})^\mu(\frac{k_{it}}{1-\mu})^{1-\mu}, 0 < \mu <1 $$
- Impose inceberg variable trade costs, such that $\tau_{nit}>1$ units of a good must be shipped from location $i$ in order for one unit to arrive in location $n$. 
- profit maximization implies the cost to the consumer in location $n$ of sourcing good produced in location $i$ depends solely on these iceberg trade costs and constant marginal costs 
$$ p_{nit} = \tau_{nit}p_{iit} = \frac{\tau_{nit}w_{it}^\mu r_{it}^{1-\mu}}{z_{it}} $$
Where $p_{iit}$ is the free on board price of the good supplied by location $i$ before trade costs
- Normalize total labor income of all location $\sum_{i=1}^N w_{it}l_{it} = 1$
### Worker consumption
- workers preferences in each period $t$ are the standard ARmington model of trade with constant elasticity of subsitution
- Workers spend wage income on products from different location to maximize utility in each period
- flow utility of a worker in location $n$ in period $t$ depends on amenities $b_{nt}$ and the consumption index $c^w_{nt}$ defined over the variety of products given as 
$$ u_{nt}^w = b_{nt}c^w_{nt}, c_{nt}^w = \left[ \sum_{i=1}^N (c_{ni}^w)^{\theta/(\theta+1)}\right]^{(\theta+1)/\theta}, \theta = \sigma -1, \sigma >1 $$
- the superscript $w$ is used to denote workers, (as opposed to?)
- $\sigma>1$ is the constant elasticity of substitution which relates to $\theta = \sigma -1$ which is the trade elasticity. 
- Indirect utility function
$$ u_{nt}^w = \frac{b_{nt}w_{nt}}{p_{nt}}, p_{nt} = \left [ \sum_{i=1}^N p_{nit}^{-\theta} \right ]^{-1/\theta} $$
- Where $b_{nt}$ are amenities in location $n$, $w_{nt}$ is the workers wage, and the dual price index $p_{nt}$ that depends on the price of varieties sourced at each location $p_{nit}$
### Capital Accumulation
- Landlords in each location choose their consumption and investment to maximize their intertemporal utility subject to their budget constraint. 
- Intertemportal utility for landlords is the expected presdent discounted valued of their flow utility
$$ v_{it}^k = \mathbb E_t \sum_{s=0}^\infty \beta^{t+s}\frac{(c^k_{i,t+s})^{1-1/\psi})}{1 - 1/\psi} $$
- The superscript $k$ denotes landlords
- the ocnsumption index $c_{it+s}^k$ is the same as the worker index $c_{nt}^w$
- $\beta$ is the discount rate
- $\psi$ is the intertemporal elasticity of substition
- because landlords are geographically immobile, we dont care about amenities in their flow utility (they say this doesnt matter in eq)
- We assume that the investment technology in each location use the varieties from all location with the same functional form as consumption.
- Landlords can produce one unit of capital in their location using one unit of the consumption index in that location. 
  + This is forcing landlords to be symmetric (an interesting extension)
- This capital depreciates at a constant rate of $\delta$, and we can let $\delta$ be greater than new investment
- the intertemporal budget constaint for landlords in each location require that total income from the existing stock of capital $r_{it}k_{it}$ equals the total value of their consumption $p_{it}c_{it}^k$ (Think profit) plus the total value of net investment $p_{it}(k_{it+1} - 1-\delta k_{it})$
- this gives the following expression
$$ r_{it}k_{it} = p_{it}(c_{it}^k _ k_{it+1} - (1-\delta)d_{it}) $$
- Let $R_{it} \equiv 1-\delta + \frac{r_{it}}{p_{it}}$
- Lemma 1: The optimal consumption of location $i's$ landlords satisfies $c_{it} = \zeta_{it}R_{it}k_{it}$ where $\zeta_{it}$ is defined recursively as 
$$\zeta_{it}^{-1}= 1 + \beta^{\psi}(\mathbb E_t[ R_{it+1}^{\psi-1/\psi}\zeta_{it+1}^{-1/\psi}])^{\psi} $$
Landlords optimal saving and investment satisfy $k_{it+1} = (1-\zeta_{it})R_{it}k_{it})$
- Lemma 1 shows that landlords have alienar saving rate $(1-\zeta_{it})$ out of current period wealth $R_{it}k_{it}$
- This savings rate is endogenous and forward-looking and depends on the expectation of the sequence of futrue returns on capital $\{R_{it+s}\}^\infty_{s=1}$, the discount rate $\beta$, and the intertemporal elasticity of substiution $\psi$
- For a special case of log utility $\psi =1$, landlords have a constant saving rate $\beta$ i.e. $k_{it+1} = \beta R_{it}k_{it}$
- As landlords are geographically immobile, this generates gradual adjustment in local capitial due to consumption smoothing. 
- Another model that can explain the same results is adjustment costs, but it is not nearly as tractable as this model.
- In steady state, even though the capital to labor ration $k^*_i/l^*_i$ can differ across locations, there is a common real rental rate in  terms of the consumption good across all locations $r^*_i/p_i^*$
- They have an extension in online supplement S.4.8 that shows how we can let landlords invest in other locations, which could be how I get entry into the model.
### Worker migration decisions
- After supplying labor and spending wage income on consumption in each period $t$, workers observe idiosyncratic mobility shocks $\epsilon_{gt}$ and decide where to move. 
- The value function for a worker in location $i$ in bet $t$ ($\mathbb V_{it}^w$) is equal to the current flow of utiliy in that location plus the expeceted continuation value form the optimal choice of location:

$$ \mathbb V_{it}^w = log(u_{it}^w) + \max \beta \mathbb E_t[\mathbb V_{gt+1}^w] - \kappa_{git} + \rho\epsilon_{gt} \} $$
- $\beta$ is the discount rate, $\mathbb E_t$ is the expectation in period $t$ over future location charactertistic. Because workers live hand to mouth, we assume log utility for workers and there is no role for the intertemporal elasticity of subsitution in their consumption decision. 
- Assume that $\epsilon_{gt}$ follows a Type-1 EV distribution with $\gamma$ the constant subtracted out. 
- $\rho$ controls the dispersion of idiosyncratic mobility shocks
- Assume the bilateral migration costs $\kappa$ satisfy $\kappa_{iit} =1$ and $\kappa_{nit} >1$
### Market clearing
- Goods market clearing implies that income in each location, which is the sum of workers and landlords, is equal to the expenditure on the poods produced by that location
$$ w_{it}l_{it} + r_{it}k_{it} = \sum_{n=1}^N S_{nit}(w_{nt}l_{nt} + r_{nt}k_{nt}) $$
- Assume that trade is balance, but we can extend that later
- Capital market clearing imples that the rental rate for capital is detemined by the requirement that landlords income from the ownership of capital equals payments for its use. Using profit mazimization and a zero profit assumtion, the market clearing condition for capital is given by
$$ r_{it}k_{it} = \frac{1-\mu}{\mu}w_{it}l_{it} $$
- Where $\mu$ is the relative share of labor to capital in the production technology. So this is something I will need to change. 

### General Equilibrium
- given the state variable $\{l_{i0},k_{i0}\}$, the general equilibrium of the economy is the stochastic process of allocation and prices such that firms in each location choose input to maximize profits, workers make consumption and migration decisions to maximize utility, landlords make consumption and investment decsiions to maximize utility, and prices clear all markets, with an appropriate measurability constaint with respect to the realization of location fundamentals.
- We can see this as a sequence of five endogenous variables $\{l_{it},k_{it},w_{it},R_{it},v_{it}\}_{t=0}^\infty$
  + All other endogenous variables of the model can be recovered as a function of these 5

#### Capital Returns and accumulation

- Using capital market clearning, the gross return on capital in each location must satisfy

$$ R_{it} = (1-\delta + \frac{1-\mu}{\mu}\frac{w_{it}l_{it}}{p_{it}k_{it}}) $$
- this makes the price index

$$ p_{nt} = \left[ \sum_{i=1}^N \left(w_{it}(\frac{1-\mu}{\mu})^{1-\mu}(l_{it}/k_{it})^{1-\mu}\tau_{ni}/z_i \right)^{-\theta}\right ]^{-1/\theta} $$
- the law of motion for capital then become

$$ k_{it+1} = (1-\zeta_{it})(1-\delta + \frac{1-\mu}{\mu}\frac{w_{it}l_{it}}{p_{it}k_{it}})k_{it} $$
#### Goods market clearing

- The CES expenditure share, the equilbirum pricing rule, and the capital market clearing condition in the goods makret clearing condition, and the requirement that income equals expenditure on the goods produced by a location can be written solely in terms of labor income

$$ w_{it}l_{it} = \sum_{n=1}^N S_{nit}w_{ni}l_{ni} $$
$$ S_{nit} = \frac{(w_{it}(l_{it}/k_{it})^{1-\mu} \tau_{ni}/z_i)^{-\theta}}{\sum_{m=1}^N (w_{mt}(l_{mt}/k_{mt})^{1-\mu} \tau_{nm}/z_m)^{-\theta}} $$
- Now define
$$ T_{int} \equiv \frac{S_{nit}w_{nt}l_{nt}}{w_{it}l_{it}} $$
- we used the property that capital income is a constant multiple of labor income, $S_{nit}$ is the expenditure share of importer $n$ on exporter $i$ at time $t$, and we have defined $T_{int}$ as the corresponding income share of exporter $i$ from importer $n$ at time $t$
- note that the order of the subscripts switches between $S$ and $T$, as these are going to correspond to rows and columns of a matrix, respectively.

#### Worker value function

- the value function, indirect utility function and properties of the EV distribution give us the expected value from living in location $n$ at time $t$ after taking expectation with respect to the idiosyncratic mobility shocks $\epsilon_{gt}$
  + i.e. $v^w_{nt} = \mathbb E_\epsilon[\mathbb V^w_{nt}]$
- this can be written as 

$$ v_{nt}^w = log(b_{nt}) + log(\frac{w_{nt}}{p_{nt}}) + \rho log\left( \sum_{g=1}^N (\exp(\beta \mathbb E_t v^w_{gt+1})/\kappa_{gnt})^{1/\rho} \right) $$
- where the expectation $\mathbb E_t\mathbb E_\epsilon[\mathbb V^w_{nt+1}]]$ is taken over future fundamental $\{z_{is},b_{is}\}_{s=t+1}^\infty$

#### Population flow
- Using properties of the EV distribution, the population flow condition for the evolution of the population distribution over time is given by

$$ l_{gt+1} = \sum_{i=1}^N D_{igt}l_{it} $$
$$ D_{igt} = \frac{(\exp(\beta\mathbb E_t v^w_{gt+1})/\kappa_{git})^{1/\rho}}{\sum_{m=1}^N (\exp(\beta\mathbb E_t v^w_{mt+1})/\kappa_{gmt})^{1/\rho} } $$
- now define

$$ E_{git} \equiv \frac{l_{it}D_{igt}}{l_{gt+1}} $$
- Where $D_{igt}$ is the outmigration probabi;ity from location $i$ to location $g$ between time $t$ and $t+1$.
- $E_{git}$ is the corresponding inmigration, with the subscripts switched as these again are going to correspond to rows and columns of a matrix.
  + Think of $E$ is to $D$ as $T$ is to $S$

### Properties of General Equilbirum

- Given the state variables $\{l_{it}, k_{it}\}$ and the realized location fundamental $\{z_{it},b_{it}\}$, the general equilibrium in each period is detemined as in a standard static internation trade mdoel. Between periods, the evolution of the stock of capital $\{k_{it}\}$ is determined by the equilibrium saving rate, and the dynamics of the population distribution $\{l_{it}\}$ are determined by the gravity equation for migration.
- Definition1  Equilbirum: given the state variables $\{l_{i0},k_{i0}\}$ in each location in an intial period $t=0$, an equilbirum s a stochastic process of wages, capital returns, expected values, mass of works, and stock of capital in each location, $\{w_{it},R_{it},v_{it}l_{it+1},k_{it+1}\}$ measureable with respect to the fundamental shocks up to time $t$ ($\{z_{is},b_{is}\}_{s=1}^t$) and solves the value function, the population flow condition, the goods market clearing condition, and the cpaital market clearing and accumulation condition, with the saving rate determined by lemma 1.
- Define a deterministic stead-state eq as one in which the fundamental $\{z_i^*,b_i^*\}$ and the endogenous variables $\{l_i^*,k_i^*,w_i^*,R_i^*,v_i^*\}$ are constant over time, where we use the star to denote steady state values.
- Definition 2 Steady State: A steady state of the economy is an equibrium in which all loation specific fundamentals and ednogenous variables (wages, expected value, mass of workers, and stock of capital) are time invariant

### Suficent conditions for existence of a unique steady state 
- the sufficent conditions for existence of a unique steady state are expressed in terms of a coefficient matrix $A$ of model paramters $\{\psi,\theta,\beta,\rho,\mu,\delta\}$ as in Allen, Arkolakis, and Li (2020)
- Proposition 1 Existence and Uniqueness: A sufficent condition for the existence and unique steady state spatial distribution of economic activity up to a choice of units given time-invariant location fundaments is that the spectral radius of the coefficient matrix $A$ of model parameters is less than or equal to 1
- Proof: Online Appendix B.2

### Trade and Migration share matrices
- Let $S$ be the $N\times N$ matrix with the $ni^{th}$ element equal to importer $n$'s expenditure on exporter $i$
- Let $T$ be the $N\times N$ matrix with the $ni^{th}$ element equal to the fraction of income that exporter $i$ derives from selling to importer $n$.
- Call $S$ the expenditure share matrix and $T$ the income share matrix. 
- $S_{ni}$ captures the importance of $i$ as a supplier to location $n$ and $T_{in}$ captures the impoirtance of $n$ as a buyer for country $i$. 
- Note that in $S$ rows are buyers and columns are supplier, whereas in matrix $T$, rows are supplier and columns are buyers.
- Now let $D$ be the $N\times N$ matrix with the $ni^{th}$ element equat to the share of outmigrant from origin $n$ to destination $i$. Let $E$ be the $N\times N$ matrix with the $ni^{th}$ element equal to the share of in-migrants from origin $n$ to destination $i$
- Call $D$ the outmigration matrix and $E$ the inmigration matrix
- $D_{ni}$ captures the likelihood that a worker in lokation $n$ migrates to lcoation $i$. 

### Dynamic Exact-Hat Algebra
- Exact hat algebra allows us to preform counterfactuals under perfect foresight in migration models from Caliendo, Dvorkin and PArro (2019) to incorporate forward-looking investment decisions
- Suppose we observe the spatial distribution of economic activity somewhere along the transition path toward an unobserved steady state. 
- given the initial observed endogeounous variables of the model, we solve for the conomies trasition path in time differences $\dot{x_{t+1}} = x_{t+1}/x_t$ for any anticipated convergent sequence of future chagnes in fundamentals, without having to solve for the unobserved inital level of fundamentals. 
- Proposition 2 Dynamic Exact Hat Algebra: Given an intial observed allocation of the economy $\{\{l_{i0}}_{i=1}^N,\{k_{i0}}_{i=1}^N,\{S_{ni0}}_{i=1}^N,\{D_{ni-1}}_{i=1}^N\}$, and a convergent sequence of future cahnges in fundamentals under perfect foresight 
$$ \{ \{\dot{z_{it}}\}_{i=1}^N,\}.\{\dot{b_{it}}\}_{i=1}^N,\}.\{\dot{\tau_{it}}\}_{i=1}^N,\}.\{\dot{\kappa_{it}}\}_{i=1}^N,\}\} $$
the solution for the sequence of changes in the models endougenous variables does not require information on the level of fundamentals 
$$ \{ \{z_{it}\}_{i=1}^N,\}.\{b_{it}\}_{i=1}^N,\}.\{\tau_{it}\}_{i=1}^N,\},\{\kappa_{it}\}_{i=1}^N,\}\} $$
- Proof: Online Appendix B.3
- The inital observed endogenous variables and the equilbirum conditions ofthe model control for the unobserved initial levle of fundamentals. 
- From this proposition, we can use dynamic exact-hat algebra method to solve for the unobserved initial steady state in the absence of any further changes in fundamentals. 
- We can also use this approach to solve counterfactuals for the transition path of the spatial distirubtion of eonomic activity in response to assumed sequences of future chagnes in fundamentals. 
- We can invert the model to solve for the unobserved chagnes in productivity, amenities, trade costs, and migration costs that are implied by the observed chagnes in the endogenous variables of the model under perfect foresight (Online Supplement S.2.1)
- We can undertake this model inversion along the transition path without making assumption about the precise sequence of future fundamentals, becasue the observed changes in migration flows and the captial stock capture agents expectation about this sequence of futrue fundamentals.

## Specteral Analysis
- To further understand the roles of capital and labor dynamics, we now linearize the model to provide an analytical chaacterization of the economies transition path using spectral analysis
- Focus on on shocks to productivity and amenities, but show that the appraoch generalizes to incorporate shocks on migration and trade costs later
- As an overview, we are going to toally differentiate the genreal equilbrium conditions of the mdoel and derive a linearized system of equations that fully characterizes the transtion path of the economy up to the first order. 
- We then solve this linearized system in closed form under a wide range of different assumptions about agents expectation
- We start with the simplest case in which agents learn about a one-time unanticipated shock to fundamentals
- We then do the special case of more complicated shocks, but in two symmetric regions.
- We then show that the model accomodates the case in which agents learn about any expected convergence sequence of futre shocks to fundamental under perfect foresight
- Then do the case in which agents ovserve an initial shock to fundamentals, and then form rational expectations about future shocks that are known to be stochastic
- For each case, we show that the clsoed form solution for the trasntion path depends on an impact matrix, which captures the inital impact of the shock to fundamentals on the state variables in the period in which they occur, and a trasition matrix, which governs the updating of the state variables over time. 
-  the impact and transtion matrices only depend on the strucural parameters of the model, and the observed matrices of expenditure shares $S$, income Share $T$, outmigration Shares $D$, and inmigration shares $E$. and hence provide first-order sufficent statstics for teh economies trasniton path.
- Using an eigen decompostion of the trasntion matrix, we sthow that bot hteh rate of converges to steady state and the evolution of the state variables along the stanstion path can be written soley in terms of the eighen values and eigenvectosr of the the trasnition matrix. 
- this allows us to show that the rate of convergence to steady state is slow and heterogenous and to demonstarate that capital accumulation and migration interact to shape the persisent and deterogenous impact of local shock. 

#### Transition path
- suppose that we observe the state variables $\{l_t,k_t\}$ (these are now vectors) and the trade and migration share matrices $\{S,T,D,E\}$ of the economy at time $t=0$
- We may not be at steady state at this time, but we assume that it is on a convergent path toward a steady state with constant fundamentals $\{z,b,\kappa,\tau\}$ (again, vectors). 
- This is the initial steady state
- Let $\tilde x_{it+1} = log x_{it+1} - log x_{it}$ denote a log deviation from the intial steady state for all variables except for the workers value function, for which we will abuse notation and let the tilde represent a deviation in levels $\tilde v_{it} = v_{it} - v_i^*$
- we begin by totally differentiating the gen eq conditons of the model around the unobserved inital steady state. Holding constant the aggregate labor endowment, trade costs and migration costs. 
- This gives us a system of linear equations that characterizes the economies transtion path up to the first order
$$
\begin{aligned}
\tilde p_t &= S(\tilde w_t - \tilde z_t - (1-\mu)(\tilde k_t - \tilde l_t)) \\
\tilde k_{t+1} &= \tilde k_t + (1- \beta(1-\delta))(\tilde w_t - \tilde p_t - \tilde k_t + \tilde l_t) \\
&+(1-\beta(1-\delta))\frac{1-\beta}{\beta}(\psi -1)\times \mathbb E_t \sum_{s=1}^\infty \beta^s(\tilde w_{t+s} - \tilde p_{t+s} - \tilde k_{t+s} - \tilde l_{t+s}) \\
[I - T + \theta(I-TS)]\tilde w_t &= [-(I-T)\tilde l_t+ \theta(I-TS)(\tilde z_t +(1-\mu)(\tilde k_t-\tilde l_t)] \\
\tilde l_{t+1} &= E\tilde l_t+ \frac{\beta}{\rho}(I-ED)\mathbb E_t \tilde v_{t+1} \\
\tilde v_t &= \tilde w_t - \tilde p_t + \tilde b_t + \beta D\mathbb E_t \tilde v_{t+1}
\end{aligned}
$$
- the derivation for this is in Oline Appendix B.4.4
- Note that there are no terms in teh change in the trade and migration share matrices, because these terms are second oder in the underling taylor series expantion because they involve interations between the chagnes in productive and amenities and the resulting chagne in trade and migration shares. 
- As we consider first order chagnes in productivity and amenities, these second-order non-lienar terms drop out of the linearization
- We can then write the trade and migration share matrices with no time subscript for first-order changes in productivity and amenities. 
  + Is this a reasonable assumption for me to make?
  
#### Transition dynamics for a one-time shock 

- We solve the economies transtion path in repsonse to a one-time shock. We suppose that agents learn at time $t=0$ that a one0time, unexpected, and permanent change in productivity and amenities from time $t=1$ onwards. 
- Under this assumption, we write the sequence of future fundamentals (productivties and amenities) relative to the inital levels as $(\tilde z_t,\tilde b_t) = (\tilde z,\tilde b)$ and we no longer need the expectation operator in the last 4 lines of equations above
- Models transiton dynamics can be reduced to the following linear system of second-order difference equation in the state-variables
$$ \Psi \tilde x_{t+2} = \Gamma \tilde x_{t+1} + \Theta\tilde x_t + \Pi\tilde f $$
- Where $\tilde x_t = (\tilde l_t, \tilde k_t)'$ is the $2N\times 1$ vector of state variable and $\tilde f$ is a $2N\times 1$ vector of shockt to fundamentals, and $\Psi,\Gamma,\Pi$ are each $2N\times 2N$ matrices that depend on the structural parameters of the model $\{\psi,\theta,\beta,\rho,\my,\delta\}$ and the ovserved trade and migration share matrices $\{S,T,D,E\}$.
- The matrix system of equation is solved using the method of undetermined coefficients following Uhlig (1999) to obtain a closed-form solution for thet economies transtion path in terms of an impact matrix $R$ which captures the initial impact of the fundmanental shocks and a trasition matrix $P$ which governs the evolution of state vairables over time. 
- Specifically, one can show that the $4N\times 4N$ matrix 

$$ \begin{pmatrix}\Psi & 0 \\ 0 & I \end{pmatrix}^{-1} \begin{pmatrix} \Gamma & \Theta \\ I & 0 \end{pmatrix} $$
Has eigenvectors of the form $[\lambda_ku_k,u_k]'$ where $\{\lambda_k\}$ are the corresponding eigen values and $\{u_k\}$ arre the $2N\times 1$ vecors. If the eigenvalues are stable, $|\lambda_k|< 1$, then the linearized system is stable and has a unique stable trasntion path.
- Propostition 3 Transtion Path: Suppose that the economy at time $t=0$ is on a convergence path toward an intial steady state with constant fundamentals $(z,b,\kappa,\tau)$. At time $t=0$, agents learn about one-time, permanent shocks to productivity and amenities ($\tilde f= [\tilde z, \tilde b]'$) from time $t=1$ onwards. There exists a $2N\times 2N$ transtion matrix $P$ and a $2N\times 2N$ impact matrix $R$ such that the second-order difference equation system above has a closed form solution of the form
$$ \tilde x_{t+1} = P\tilde x_t + R \tilde f, \forall t \geq 0 $$
The transition matrix $P$ satisfies 

$$ P = U \Lambda U^{-1} $$

Where $\Lambda$ os a diagonal matrix of $2N$ stable eigenvalues and $U$ is a matrix stacking the corresponding $2N$ eigenvectors. the impact matrix $R$ is given by 
$$ R = (\Psi P + \Psi - \Gamma)^{-1}\Pi $$
Where $(\Psi,\Gamma,\Theta,\Pi)$ are the matrices from the system of second-order difference equations
- Proof: Online appendix B.4.6
- The solutions ofr these matrices $P,R$ depend only on the structural paramters of the model and the observed trade and migration share matrices
### Convergence Dynamics vs Fundamental Shocks
- Using the clsoed form solution in Proposition 3, the transition path of the economies state variables can be additively decompsed into the contributions of convergence dynamics given intial conditions and fundamental shocks. 
- Taking the first expression from proposition 3 and applying across time periods, we obtain
$$ log(x_t) - log(x{-1}) = \sum_{s=0}^t P^s(log(x_0) - log(x_{-1}) ) + \sum_{s=0}^{t-1} P^sR\tilde f $$
- Where the first term on the right is the convergence given intial fundamentals and the seond term is dynamics from the fundamental shock
- If we have no shock $\tilde f = 0$ then the convergence is govern only by the inital conditions and converges over time to 
$$ log(x^*_{init}) = \lim_{t\to \infty} log(x_{-1}) + (I-P)^{-1}(log(x_0) - log(x_{-1})) $$
 Where $(I-P)^{-1} = \sum_{s=0}^\infty P^s$ is well defined under the condtion that the spectral radius of $P$ is smaller than one.
 - In contrast, if the economy is intially in a steady state at time 0, the first term on the right hand side is zero, and the trastion path of the state variables is solely driven bt the seoncd term for fundamental shocks, and follows
 
$$ \tilde x_t = log(x_t) - log(x_0) = \sum_{s=0}^{t-1} P^sR\tilde f = (I-P^t)(I-P)^{-1}R\tilde f, \forall t\geq 1 $$
- In the period $t=1$ when shocks occur, the response of the state variables is $\tilde x_1 = R\tilde f$. Taking the limit as $t\to \infty}$, the comparitive static steady state response is 
$$ \lim_{t\to\infty} \tilde x_t = log(x^*_{new}) 0 log(x^*_{init}) = (I-P)^{-1}R\tilde f $$
- A key implication of this additive separability in the decomposition is that we can examine the economies dynamic response to fundamental shocks separately from its converages towards an intal steady state with unchanged fundamentals. 
- That lets us focus on an economy that is initially in a steady state (is that something I can test empirically?)
### Spectral analysis of the transition matrix
- This section provides furher analytical characterization of the roles of capital and labor dynamics in shaping the economies gradual adjustment to shocks using a spectral analysis of the transtiona matrix
- Decompose the transition matrix into $P = U \Lambda V$
  + $\Lambda$ contains the eigenvalues in decreasing order and $V = U^{-1}$
- For each eigen value $\lambda_h$ the $h^{th}$ column of $U$ ($u_h$) and the $h^{th}$ row of $V$ ($v'_h$) are the right and left eigenvectors of $p$ respectively, such that

$$ \lambda_h u_h = Pu_h, \lambda_h v'_h = v'_h P $$
- This tells us that $u_h (v'_h)$ is the vector when left (right) multiplied by $P$ is proportional to itself but scaled by the corresponding eigenvalue $\lambda_h$
- Both $\{u_h\}$ and $\{v'_h\}$ are bases that span the $2N$ dimensional vector space
#### Eigenshocks
- We now introduce a particular type of shock to fundamentals that proves useful for characterizing the models transtion dynamics. 
- Define an eigenshock as a nonzero shock to productivity and amenties $\tilde f_h$, for which the initial impact of these shocks on the state variables $R \tilde f$ coincides with a real eigenvector of the transiton matrix $u_h$ or the zero vector
- Eigenshocks $\{\tilde f_h\}$ also form a bases for the $2N$ dimensional shock space.
- Each eigenvector of $P$ with a nonzero eigenvalue has a corresponding eigenshock for which $R\tilde f_h = u_h$
- Let the nonzero eigenvalues be called non-trivial, because it affects the dynamics of the state variables. 
- $P$ has an eingen vector $[1,\dots ,1,0,\dots ,0]'$ with a zero eigenvalue $\lambda_1= 0$ because population shares sum to one and thus one of hte 2N dimensions of the state space is redundant
- the corresponding fundamental shock $\tilde f_1$ is a vector of a common amenity shock to all location. Such a common amenity shock affects worker flow utility, but does not affect any prices or quantities in the equilibrium, and thus is trivial in the sense that it does not affect the dynamics of the state variables. Let the first index always be this trivial eigencomponent. 
- In general, empirical shocks should not have to correspond to an eigenshock. 
- But we can use these eigenshocks to characterize the impact of any empircal shock using the followign two properties
  + We can slve for these shocks from the sobseved data because the impact matrix $R$ and the transtion matrix $P$ depend soley on our observed trade and migration share matrices and the strucutral parameters of the model
  + Any empirical productivity and amenity shocks $\tilde f$ can be expresed as a lienar combination of the eigen shocks $\tilde f_h$ where the weights or loadings in this linear combination can be recovered via OLS of the observed shocks on the eignshocks. 
- Using this property, the transtion path of the state variables in response to any empirical productivty and amenity shocks can be expressed solely in terms of the eigenvalues and eigne vectors of the trasntion matrix
- Proposition 4 Spectral Analysis: Consider an economiy that is initally in steady state at time $t=0$ when agents learn about onetime, permanent shock to productivty and amenities, from time $t=1$ onwards. the trasnsition path of hte state variables can be written as a linear combination of the eigen values and eigenvectors of the stranstion matrix 
$$ \tilde x_t = \sum_{s=0}^{t-1} P^wR\tilde f = \sum_{h=1}^{2N} \frac{1-\lambda_h'}{1-\lambda_h}u_ha_h $$
Where the weights $a_h$ can be be recovered as the coefficents in a regression of the observed shocks $\tidle f$ on the eigen shocks $\tilde f_h$
- Proof: ONline Appendix B.4.9
- the speed of convergece to steady state for an eigen shock as measured by the half-life of convergence to steady state depens solely on the associated eigen value of the transtion matrix and is summarized in the following proposition
- Prop 5 Speed of Convergence: Consider an economy that is intially in steady state at time $t=0$ and agents learn about a one0time, permanent shoc to productive and amenities form time $t=1$ onwards. Suppose that these shocks are a nontrivial eigenshock, for which teh intial impact on the state variables at time $t=1$ conicides with a real eigenvector $u_h$ of the trasition matrix $P$. The trasntion path of the state variables in response to such as shock is 

$$ \tilde x_t = \sum_{j=2}^{2N} \frac{1-\lambda_j'}{1-\lambda_j}u_jv_j'u_j = \frac{1-\lambda_h'}{1-\lambda_h}u_h \Rightarrow log(x_{t+1}) - log(x_t) = \lambda_h^tu_h $$
- Proof: Oline appendix B.4.9
- The impact of a nontrivial eigenshock on the state variables in each time period is always proportional to the corresponding eigne vector and ecays expontially at a rate determined by the associated eigenvalue
- These eigen values fully summarize the economies speed of convergence in response to eigenshcoks, even in our setting with a high dimensional state space, a rich geography of trade and migration costs, and multiple sources of dynamics
- In general, each eigenshock has a different speed of convergence as captured by its eigenvalue which reflects the fact thta the speed of convergence to steady state does not only depend on strucutreal parameters but also on the incidence of the shock on the labor and captial state variables in each location. 

### Two location example
- We now look at an example with two symmetric location that begin in steady state. Location symmetry and triade and migration friction imply that the expenditrue and migration share matrices $S$ and $D$ are symmetric and diagonal-dominant, with $T=S$ and $E=D$
- Suppose that at time $t=0$ agents learn about one-time, permanent shock to productivity and amenities captured by the vector $\tilde f$ in log-deviation form the intial steady state values
- The process follows three steps
- First, we write the dynamic response of the state vairables in log deviation form the intial steady state value $\tilde x_t = [log(l_t) - log(l^*),log(k_t) - log(k^*)]'$ using Proposition 3
$$ \tilde x_{t+1} = P\tilde x_t + R\tilde f, \forall t \geq 0, \tilde x_0 = 0 $$
- therefore, the intial impact of the fundamental shock $\tilde f$ is governed by the impact matrix $R$ via

$$ \tilde x_1 = R\tilde f $$
- the subsequent updating of the state variables is regulated by the trasntion matrix $P$

$$ \tilde x_{t+1} - \tilde x_t = P^t \tilde x_1, \forall t\geq 0 $$

- since each location ahs two state variables, population and capital stock, the transtion matrix $P$ is $4\times 4$. Likewise, becasue each location is subject to two shocks (to productivity and amenities), the impact matrix is also 4x4.
- In step 2, we express this dynamic response of the state variables in terms of the eigenvectors and eigenvalues of the trasition matrix $P$ using prop 4. First we rewrite the recurisvie formulation in sequence form $\tilde x_t$ = (\sum_{s=0}^{t-1}P^s)R\tilde f$. 
- Next we use a eigendecompistion of $P$ to rewrite the summation over iterative powers of $P$ as a summation ver the components of the eigenbasis of $P$
$$ \tilde x_t = \sum_{h=1}^4 \frac{1-\lambda_h'}{1-\lambda_h}u_hv'_hR\tilde f $$
- in step 3, we write the impact of an empircal shock on the state variables $(R\tilde f)$ as a lienar combination of the eigenshocks using prop 5. First define a nontrivial eigenshock $\tilde f_h$ as a shock to the fundamnetals for which the initial impact of the shock on the state variable $R\tilde_h$ correspons to a right eigenvector of the trastion matrix $(u_h)$. 
- for such a non-trivial eigenshock, the dynamic impact on the state variables can be fully characterized by the $h^{th} eigencomponent alone
$$ \tilde x_{t+1} - \tilde x_t |_{\tilde f = \tilde f_h} = \lambda_h^t u_h, \tilde x_t|_{\tilde f= \tilde f_h} = \frac{1-\lambda_h'}{1-\lambda_h}u_h $$
- the rate of convergence to the new steady state depends only on the corresponding eigenvalue $\lambda_h$.
- the larger the value of this eigenvalue, the slower the rate of convergence to steady state. 
- seond, we use the property that the impact of any empircal shock $R\tilde f$ can be written as a linear combination of the impact of the eigenshocks $R\tilde f = \sum_{i=1}^{2N}a_iR\tilde f_i$, where we can recover the weights in this linear combination form a a regresion. 
- the eigenvectors and eigne values of $P$ depend not only on the model paramters but also on the entire trade and migration matrices. 
- But in the symmetric two location example, the four eignevectors of the trastion matrix $P$ take the simple form

$$ [1,1,0,0,]',[0,0,1,1]', [1,-1,\alpha,-\alpha]', [1, -1, -\xi, \xi] $$
For some constants $\alpha$ and $\xi$ that depend on model parameters aand the trade and migration share, as shown in appendix B.4.10
- The eigenvectors of $P$ have an intutitive interprestation
- the first eigenvector has an associated eigenvalue of zoer and corresponding eigenshock of $[\tilde z_1, \tilde z_2, \tilde b_1, \tilde b_2]' = [0,0,1,1]'$. this tricival eigenshock captures a common amentity shock to both location that leaves population shares and captial stocks unchaned. 
- the assocaited eigenvalue is zero, since the intial and new steady state coincide, such that there is immediate convergence with no trastional dynamics.
- the second eigen vector has an associated eigen shock of exactly the opposite order. This eigencompoment captures a common productivity shock to both location
- Becasue we are symmetric, this leaves population shares unchanged, such that the first two entries are 0. 
- but his productivity shock leads to a symmetric reduction in the consumer orice index, and hence the cost of captial in both location, which affects capital dynamics in bot hlocation symmetrically, which makes the thrid and fourth entries in $u_2$ equal. 
- In the symmetric example, captial dynamics in response to this common productivity shock are the smae as they would be in a single location clsoed economy. 
- the eigenvalue of thsi componeent can be charcterized analytically. 
- in the specail case in whihc landlords have a unitary elasticity of intermporal substitution (log utility), the corresponding eigenvalue is $[1-(1-\beta(1-\delta)\mu)]$
- the remaining two eigne vectors captures shocks that are asymetric across location. 
- the thrid eigenvector is associated with an eigenshock dependent on a constant $c$ 
- the fourth eigen vector is assocaied with an eigen shock dependent on a constant $d$. 
- in both cases, the deviations of the state variables form stated state in location 1 take the same absilute value, but have the opposite sign to the deviations of the steate variables from steady state for location 2.
- We cannot theortically sing the constants $\alpha,\xi,c,d$, we find fumerically that ll these parameters are positive for realistic parameter values. 
- Under sign restriction, $u_3$ can be thought of as capturing the case in which productivity and amentity shocks are positively correlated across location, and the other eigenvecotr capture the case in which they are negatively correalte. 
- The third eigen value captures the case the new steady steate values of labor and captial are both above their intiavl value in the location that experience positive shocks , and both below in their intal vales in the in the location that experience negative shocks. 
- In contrast, the fourth eigenvector captures the case in which productivty and amenity shocks are negatively orrelated across location. Therefore, each location experience productivity and amenity shocks that are the oppostie sign to one another. 
- Consequently, the new steady steate features a higher population shrae but lower capital in one location, and lower population share but higher captial stock in the other location. 
- In all numerical simulation, we find that the eigenvalue for the thrid eigenvector is higher than the fourth
- this tells us that economies experiecne slower convergence to steady state if productity and amentity shocks are positively correlated across location
- the reason is the interaction between the marginal productivitys of capital and labor in the production technology.
- When both captiual and labor are above steady state, the high captial stock raise the marginal product of labor, which retards the downward adjustment of labor
- similarly, the high labor suply incrase the marginal priduct for captual, which dampens the dowanward adjustment of captial
- when bot hcaptial and labor abelow steady state, the opposite logic applies
- Any pattern of prodcutivity and amenity shocks aross the two symmetic location can be captured by a linar combination of these four types of shocks. 
#### Transtion dynamic for sequences of shocks. 
- above has focused on trastion dynamics for a one-time shock, the approach generalized to a sequence of shocks
- Prop S.1 in the Oline Supplement S.2.3 provides the closed form solution for the eoncomis trasntiion path for any convergent equence of future shock to productiveies and amenties under perfect foresight
- 

### Code REview


```
#==================================================#
# Dynamic Spatial General Equilibrium
# May 2022
# Main single sector output file
#==================================================#

#==================================================#
# paths
#==================================================#

# the variable "path" must contain the path to the replication folder

if Sys.iswindows()
        if ENV["USERNAME"] == "Benny"
                path = "C:/Users/Benny/Dropbox (Princeton)/SSTD/ECTAcondaccept/replication"
        end
else
        if ENV["USER"] == "ernestliu"
                path = "/Users/ernestliu/Dropbox (Princeton)/ProjectsActive/SSTD/ECTArevision/replication"
        end
        if ENV["USER"] == "nxiang"
                path = "/Users/nxiang/Dropbox (Princeton)/RA-Nan-Xiang/SSTD/replication" # added by Nan
        end
end


# set working directory
cd(path * "/ModelSingleSector")

#==================================================#
# load packages and  functions file
#==================================================#

include("loadpackages.jl")
include("project_functions.jl")

#==================================================#
# baseline parameters
#==================================================#

# EIS
baseψ = 1.0
# discounting factor
baseβ = 0.95^5
# migration elasticity
baseρ = baseβ * 3.0
# trade elasticity
baseθ = 5.0
# labor share in production
baseμ = 0.65
# persistence parameter
baseξ = 0.0
# depreciation
baseδ = 1 - 0.95^5
# tradable share
baseγ = 0.35

# year range
years = 1960:2017

#==================================================#
# load data and prepare dataframes for model output
#==================================================#

@load "data/modeldata.jld2" Ddata Sdata ldata wdata rdata kdata μdata χdata γdata stateabrv statedf bilateral_data
select!(statedf, :year, :statefp, :state, :region, :division, :areakm, :state_abrv, :pop, :gdp, :laborinc, :gos, :rgos)

# number of regions
N = length(ldata[1])

#==================================================#
# create economic regions
#==================================================#

rustbelt = ["Illinois", "Indiana", "Michigan", "New York", "Ohio", "Pennsylvania", "West Virginia", "Wisconsin"]
sunbelt = ["Arizona", "California", "Florida", "New Mexico", "Nevada"]
othersouth = ["Texas", "Arkansas", "Louisiana", "Tennessee", "Mississippi", "Alabama", "Georgia", "South Carolina", "North Carolina", "Virginia"]

statedf.ecoregion = fill("Other North", nrow(statedf))
statedf[in.(statedf.state, Ref(sunbelt)), :ecoregion] .= "Sun Belt"
statedf[in.(statedf.state, Ref(rustbelt)), :ecoregion] .= "Rust Belt"
statedf[in.(statedf.state, Ref(othersouth)), :ecoregion] .= "Other South"

# region array
regions = ["Rust Belt"; "Sun Belt"; "Other North"; "Other South"]
stateregions = statedf[statedf.year.==years[1], :].ecoregion

#======================================================================#
# Recover shocks for selected years and plot changes in fundamentals
#======================================================================#

# selected years and their indices
firstyear = 1990
lastyear = 2000
indfirst = findfirst(years .== firstyear)
indlast = findfirst(years .== lastyear)

# invert fundamentals for selected years
z1, τ1, κ1, b1 = invertSymfundamentals(Ddata[indfirst], Ddata[indfirst+5], Sdata[indfirst], ldata[indfirst], χdata[indfirst], [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, γdata[indfirst]], w=wdata[indfirst])
z2, τ2, κ2, b2 = invertSymfundamentals(Ddata[indlast], Ddata[indlast+5], Sdata[indlast], ldata[indlast], χdata[indlast], [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, γdata[indlast]], w=wdata[indlast])

# relative changes in fundamentals
ẑ = z2 ./ z1

# plot changes in fundamentals - productivity (z)
plt = histogram(ẑ, color=:crimson, alpha=0.5, legend=false, normalize=true)
xlabel!("Relative productivity shocks $(years[indfirst])-$(years[indlast])")
# Plots.savefig(plt, "figures/recovered_zhat_$(years[indfirst])-$(years[indlast]).pdf")
Plots.savefig(plt, "figures/Figure_S_6_15a.pdf")

# plot changes in fundamentals - amenities (b)
plt = histogram(b2 ./ b1, color=:crimson, alpha=0.5, legend=false, normalize=true)
xlabel!("Relative amenity shocks $(years[indfirst])-$(years[indlast])")
# Plots.savefig(plt, "figures/recovered_bhat_$(years[indfirst])-$(years[indlast]).pdf")
Plots.savefig(plt, "figures/Figure_S_6_15b.pdf")

#==================================================#
# invert fundamentals for all years and export data
#==================================================#

# preallocate space for model fundamentals
statedf.z = fill(0.0, nrow(statedf))
statedf.b = fill(0.0, nrow(statedf))
statedf.kapin = fill(0.0, nrow(statedf))
statedf.tauin = fill(0.0, nrow(statedf))
statedf.kapout = fill(0.0, nrow(statedf))
statedf.tauout = fill(0.0, nrow(statedf))
statedf.kapinnorm = fill(0.0, nrow(statedf))
statedf.tauinnorm = fill(0.0, nrow(statedf))

# preallocate space for model fundamentals (annual vectors)
zvec = [zeros(N) for t = 1:length(years)-5]
bvec = [zeros(N) for t = 1:length(years)-5]
τvec = [zeros(N, N) for t = 1:length(years)-5]
κvec = [zeros(N, N) for t = 1:length(years)-5]

# preallocate space for migration rates
statedf.s = fill(0.0, nrow(statedf))
statedf.d = fill(0.0, nrow(statedf))

# preallocate space for bilateral model fundamentals
bilateral_data.kap = fill(0.0, nrow(bilateral_data))
bilateral_data.tau = fill(0.0, nrow(bilateral_data))


for t = 6:length(years)

        println(years[t], " ", t)

        # parameters vector
        parameters = [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, γdata[t]]

        # invert fundamentals
        z, τ, κ, b = invertSymfundamentals(sharefunc(Ddata[t-5] .+ 10^-6), sharefunc(Ddata[t] .+ 10^-10), sharefunc(Sdata[t] .+ 10^-10), ldata[t], χdata[t], parameters, full=true)

        # save productivity and amenities
        statedf[statedf.year.==years[t], :z] .= z ./ mean(z, weights(ldata[t]))
        zvec[t-5] .= z ./ mean(z, weights(ldata[t]))
        statedf[statedf.year.==years[t], :b] .= b ./ mean(b, weights(ldata[t]))
        bvec[t-5] .= b ./ mean(b, weights(ldata[t]))

        # save bilateral trade and migration frictions
        κvec[t-5] .= κ
        τvec[t-5] .= τ

        # save unilateral summary frictions
        statedf[statedf.year.==years[t], :kapin] .= vec(exp.(sum(Ddata[t] .* log.(κ), dims=2)))
        statedf[statedf.year.==years[t], :tauin] .= vec(exp.(sum(Sdata[t] .* log.(τ), dims=2)))
        statedf[statedf.year.==years[t], :kapout] .= vec(exp.(sum(Emat(Ddata[t]) .* log.(κ), dims=2)))
        statedf[statedf.year.==years[t], :tauout] .= vec(exp.(sum(Tmat(Sdata[t]) .* log.(τ), dims=2)))

        # normalize by self-trade share
        statedf[statedf.year.==years[t], :kapinnorm] .= vec(exp.(sum(Ddata[t] .* log.(κ), dims=2) ./ (1 .- diag(Ddata[t]))))
        statedf[statedf.year.==years[t], :tauinnorm] .= vec(exp.(sum(Sdata[t] .* log.(τ), dims=2) ./ (1 .- diag(Sdata[t]))))

        # save migration rates
        statedf[statedf.year.==years[t], :s] .= vec(diag(Sdata[t]))
        statedf[statedf.year.==years[t], :d] .= vec(diag(Ddata[t]))

        bilateral_data[bilateral_data.year.==years[t], :kap] .= vec(κ)
        bilateral_data[bilateral_data.year.==years[t], :tau] .= vec(τ')
end

# export model output
CSV.write("data/fundamentals.csv", statedf)
CSV.write("data/fundamentals_bilateral.csv", bilateral_data)

#======================================================================#
# compute final SS for each year
#======================================================================#

# preallocate space for model fundamentals
statedf.l = fill(0.0, nrow(statedf))
statedf.k = fill(0.0, nrow(statedf))
statedf.chi = fill(0.0, nrow(statedf))
statedf.lss = fill(0.0, nrow(statedf))
statedf.lss_nok = fill(0.0, nrow(statedf))
statedf.kss = fill(0.0, nrow(statedf))
statedf.chiss = fill(0.0, nrow(statedf))
statedf.lss_shocks = fill(0.0, nrow(statedf))
statedf.kss_shocks = fill(0.0, nrow(statedf))
statedf.lss_shocks_alt = fill(0.0, nrow(statedf))
statedf.kss_shocks_alt = fill(0.0, nrow(statedf))

# preallocate space for outmigration data
outmigshares_data = zeros(length(years))
outmigshares_ss = zeros(length(years))
migration_ss = [zeros(size(Ddata[1])) for t = 6:length(years)]
ssgaps = [zeros(N) for t = 1:length(years)-5]

# shocks structure
Nmat = diagm([fill(0.02, N); fill(0.028, N)])

for t = 6:length(years)

        println(years[t])
        parameters = [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, γdata[t]]

        l0 = ldata[t-5]
        D0 = Ddata[t-5]
        l1 = D0' * l0
        χ0 = kdata[t-5] ./ statedf[statedf.year.==years[t-5], :].pop  #ldata[t-5]
        χ1 = kdata[t] ./ statedf[statedf.year.==years[t], :].pop #ldata[t]
        S0 = Sdata[t-5]
        N = length(l0)

        # fundamentals
        z1 = zvec[t-5]
        b1 = bvec[t-5]
        if t >= 11
                z0 = zvec[t-10]
                b0 = bvec[t-10]
                f̃ = log.([z1 ./ z0; b1 ./ b0])
        else
                f̃ = zeros(2 * N)
        end
        if t <= length(years) - 5
                z2 = zvec[t]
                b2 = bvec[t]
                f̃alt = log.([z2 ./ z1; b2 ./ b1])
        else
                f̃alt = zeros(2 * N)
        end

        # matrices
        P, R, A, B = Pmat(S0, Tmat(S0), D0, Emat(D0), parameters, AB=true)
        auxnorm = [Qmat(D0) zeros(size(D0)); zeros(size(D0)) zeros(size(D0))]
        P = (I - auxnorm) * P
        R = (I - auxnorm) * R

        x0 = log.([l0; χ0])
        x1 = log.([l1; χ1])

        # steady state values
        xss = x0 + (I - P + auxnorm)^-1 * (x1 - x0)
        lss = sharefunc(exp.(xss[1:N]))
        χss = exp.(xss[N+1:end])
        ssgaps[t-5] = xss - x0

        # steady state values with shocks
        xss_shocks = x0 + (I - P + auxnorm)^-1 * (R * Nmat * (I - Nmat)^-1 * f̃ + (x1 - x0))
        lss_shocks = sharefunc(exp.(xss_shocks[1:N]))
        χss_shocks = exp.(xss_shocks[N+1:end])

        # steady state values with shocks - alternative specification
        xss_shocks_alt = x0 + (I - P + auxnorm)^-1 * (R * (I - Nmat)^-1 * f̃alt + (x1 - x0))
        lss_shocks_alt = sharefunc(exp.(xss_shocks_alt[1:N]))
        χss_shocks_alt = exp.(xss_shocks_alt[N+1:end])

        # compute changes in D - requires A and B matrices
        dv_ss2init = (I - baseβ * D0)^-1 * (A * log.(lss ./ l0) + B * log.(χss ./ χ0))
        û_ss2init = exp.((baseβ / baseρ) * dv_ss2init)
        Dss = sharefunc(D0 .* repeat(û_ss2init', N))
        migration_ss[t-5] .= Dss .* repeat(lss, 1, N)

        #scatter(vec(Dss),vec(D0))
        outmigshares_data[t] = 1 - tr(D0 .* (repeat(l0, 1, N)))
        outmigshares_ss[t] = 1 - tr(Dss .* (repeat(lss, 1, N)))

        # no capital steady state
        P, R = Pmat(S0, Tmat(S0), D0, Emat(D0), [baseβ, baseρ, baseθ, 1.0, baseξ, baseδ, γdata[t]])
        auxnorm = [Qmat(D0) zeros(size(D0)); zeros(size(D0)) zeros(size(D0))]
        P = (I - Qmat(D0)) * P
        R = (I - Qmat(D0)) * R
        lss_nok = sharefunc(exp.(log.(l0) + (I - P + Qmat(D0))^-1 * (log.(l1) - log.(l0))))

        statedf[statedf.year.==years[t], :l] .= l1
        statedf[statedf.year.==years[t], :k] .= χ1 .* l1
        statedf[statedf.year.==years[t], :lss] .= lss
        statedf[statedf.year.==years[t], :lss_nok] .= lss_nok
        statedf[statedf.year.==years[t], :kss] .= χss .* lss
        statedf[statedf.year.==years[t], :chiss] .= χss
        statedf[statedf.year.==years[t], :lss_shocks] .= lss_shocks
        statedf[statedf.year.==years[t], :kss_shocks] .= χss_shocks .* lss_shocks
        statedf[statedf.year.==years[t], :lss_shocks_alt] .= lss_shocks_alt
        statedf[statedf.year.==years[t], :kss_shocks_alt] .= χss_shocks_alt .* lss_shocks_alt
end

CSV.write("data/steadystate_gaps.csv", statedf)

#======================================================================#
# compute final SS for each year - Non-linear model
#======================================================================#

# placeholders for results for the non-linear model
statedfnl = copy(statedf)
statedfnl.l = fill(0.0, nrow(statedfnl))
statedfnl.k = fill(0.0, nrow(statedfnl))
statedfnl.chi = fill(0.0, nrow(statedfnl))
statedfnl.lss = fill(0.0, nrow(statedfnl))
statedfnl.kss = fill(0.0, nrow(statedfnl))
statedfnl.chiss = fill(0.0, nrow(statedfnl))

# time periods for NL solution
T = 150

# fundamentals path (no changes)
fundamentalshat_path = [[ones(N) for t = 1:T], [ones(N, N) for t = 1:T], [ones(N, N) for t = 1:T], [ones(N) for t = 1:T]]

# save paths of population and capital
lpathsnl = []
χpathsnl = []

for t = 8:length(years)

        println(years[t])
        parameters = [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, γdata[t]]

        l0 = ldata[t-5]
        D0 = Ddata[t-5]
        l1 = D0' * l0
        χ0 = kdata[t-5] ./ statedf[statedf.year.==years[t-5], :].pop  #ldata[t-5]
        χ1 = kdata[t] ./ statedf[statedf.year.==years[t], :].pop #ldata[t]
        S0 = Sdata[t-5]
        N = length(l0)

        # compute transition
        upath, lpath, wpath, phpath, χpath, Rpath, ςpath, Spath, Dpath = transition2sschangesCRRA(parameters, baseψ, fundamentalshat_path, l0, l1, χ0, χ1, D0, S0, damp=0.95, ctol=10^-5, innerctol=10^-2, displaygap=false)

        push!(lpathsnl, lpath)
        push!(χpathsnl, χpath)

        statedfnl[statedfnl.year.==years[t], :l] .= l1
        statedfnl[statedfnl.year.==years[t], :k] .= χ1 .* l1
        statedfnl[statedfnl.year.==years[t], :lss] .= lpath[:, end]
        statedfnl[statedfnl.year.==years[t], :kss] .= χpath[:, end] .* lpath[:, end]
end

CSV.write("data/steadystate_gaps_nl.csv", statedfnl)


#======================================================================#
# Convergence to SS in different years - Predictive power plot
#======================================================================#

T = 20

# chose years to start convergence
yearset = [1965, 1975, 1985, 1995]
# year ranges for each series to put on x axis
x = [year-5:(5):(2040) for (i, year) in enumerate(yearset)]
# parameters for each series
params = [[baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, γdata[findfirst(years .== year)]] for year in yearset]
# P and R matrices for each series
PR = [Pmat(Sdata[findfirst(years .== year)-5], Ddata[findfirst(years .== year)-5], params[findfirst(yearset .== year)]) for year in yearset]
auxnormats = [[Qmat(Ddata[findfirst(years .== year)-5]) zeros(size(Ddata[1])); zeros(size(Ddata[1])) zeros(size(Ddata[1]))] for year in yearset]

# P matrices
P = [(I - auxnormats[i]) * PR[i][1] for i = 1:length(PR)]
# R matrices
R = [(I - auxnormats[i]) * PR[i][2] for i = 1:length(PR)]

# initial conditions for each seriesr
x0 = [log.([(Ddata[findfirst(years .== year)-5]'^-1) * ldata[findfirst(years .== year)]; χdata[findfirst(years .== year)-5]]) for year in yearset]
x1 = [log.([ldata[findfirst(years .== year)]; χdata[findfirst(years .== year)]]) for year in yearset]

# transition paths - data
lpath = hcat(ldata...)
χpath = hcat(χdata...)
kpath = χpath .* lpath;
kpath = kpath ./ sum(kpath, dims=1);
# transition paths - model
paths = [getPath(P[i], R[i], ones(2 * N), x0[i], x1[i], length(x[i])) for i = 1:length(PR)]
lpaths = [paths[i][1] for i = 1:length(yearset)]

for startyear in [1965, 1975, 1985, 1995]
        g_actual = log.(lpath[:, end-2] ./ lpath[:, findfirst(years .== startyear)])
        chosenpath = lpaths[findfirst(yearset .== startyear)]
        g_predict = log.(chosenpath[:, Int((2015 - startyear) / 5)] ./ chosenpath[:, 2])
        w = lpath[:, findfirst(years .== startyear)]
        CSV.write("data/predict_$(startyear)-2015.csv", DataFrame(g_actual=g_actual, g_predict=g_predict, w=w))
        Plots.scatter(g_predict, g_actual, smooth=true, color=:coral3, alpha=0.8, markersize=50 * w .^ 0.5, markerstrokewidth=0, legend=:false)
end

#======================================================================#
# Recover Half-lifes of different eigen-components over time
#======================================================================#

inityear = 1965
lastyear = 2015
t1 = findfirst(years .== inityear)
t2 = findfirst(years .== lastyear)
T = 100
N = 49
parameters = [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, γdata[t1]]
# get shocks
z1, τ1, κ1, b1 = invertSymfundamentals(Ddata[t1-5], Ddata[t1], Sdata[t1], ldata[t1], χdata[t1], parameters)
z2, τ2, κ2, b2 = invertSymfundamentals(Ddata[t2-5], Ddata[t2], Sdata[t2], ldata[t2], χdata[t2], parameters)
ẑ = z2 ./ z1
b̂ = b2 ./ b1

# compute half-lives for each year
halflives = []
halflives_nok = []
α = []
yearrang = 1965:2017
f̃ = log.([ẑ; b̂])
for year in yearrang
        println(year)
        t1 = findfirst(years .== year)
        P, R = Pmat(Sdata[t1-5], Ddata[t1-5], [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, γdata[t1]])
        auxnorm = [Qmat(Ddata[t1-5]) zeros(size(Ddata[t1-5])); zeros(size(Ddata[t1-5])) zeros(size(Ddata[t1-5]))]
        P = [I zeros(N, N); I I] * (I - auxnorm) * P * [I zeros(N, N); -I I]
        R = [I zeros(N, N); I I] * (I - auxnorm) * R


        # half-lives
        hl = -ceil.(log(2) ./ log.(real.(eigen(P).values[2:end])))
        U = eigen(P).vectors
        V = U^-1
        push!(halflives, hl)
        push!(α, V * R * f̃)

        P_nok, R_nok = Pmat(Sdata[t1-5], Ddata[t1-5], [baseβ, baseρ, baseθ, 1.0, baseξ, baseδ, γdata[t1]])
        auxnorm = Qmat(Ddata[t1-5])
        P_nok = (I - auxnorm) * P_nok
        R_nok = (I - auxnorm) * R_nok
        hl_nok = -ceil.(log(2) ./ log.(real.(eigen(P_nok).values[2:end])))
        push!(halflives_nok, [-999 * ones(N); hl_nok])
end

nn = length(halflives[1])
hloutput = DataFrame(vcat([[Int.(fill(yearrang[i], nn)) Int.(1:nn) 5 * halflives[i] 5 * halflives_nok[i] real.(α[i][1:end-1])] for i = 1:length(yearrang)]...), :auto)
CSV.write("data/halflives_1965-2017.csv", hloutput)

#======================================================================#
# Changes in the slopes over time
#======================================================================#

getslope(X, y) = (X' * X)^-1 * (X' * y)
demean(x) = x .- mean(x)

# regression slopes of L SS-gaps on K SS-gaps
slopes_over_time = [getslope([ones(N) ssgaps[i][1:N]], ssgaps[i][N+1:end])[2] for i = 1:length(years)-5]
plt = Plots.plot(1965:2017, slopes_over_time, legend=:false, color=:crimson)
hline!([0], line=(:black, :dash))
plot!(titlefont=9, legendfont=8, ytickfont=6, xtickfont=6, yguidefontsize=6, xguidefontsize=6)
ylabel!("Regression slope: L SS-gap on K SS-gap")
Plots.savefig(plt, "figures/slopes_over_time_gaps.pdf")

# regression slopes of b-shocks on z-shocks
slopes_over_time = [getslope([ones(N) log.(bvec[i+5] ./ bvec[i])], log.(zvec[i+5] ./ zvec[i]))[2] for i = 1:length(years)-10]
plt = Plots.plot(1968:2015, slopes_over_time, legend=:false, color=:crimson)
hline!([0], line=(:black, :dash))
plot!(titlefont=9, legendfont=8, ytickfont=6, xtickfont=6, yguidefontsize=6, xguidefontsize=6)
ylabel!("Regression slope: b -shocks on z-shocks")
Plots.savefig(plt, "figures/slopes_over_time_shocks.pdf")

#==================================================#
# Get to the steady state of a selected year
#==================================================#

# baseline year
year0 = 1975
t0 = findfirst(years .== year0)

# parameters
parameters = [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, baseγ]
baseψ = 1.0

# initial conditions from the data
l0d = ldata[t0-5]
D0d = Ddata[t0-5]
l1d = D0d' * l0d
χ0d = kdata[t0-5] ./ statedf[statedf.year.==years[t0-5], :].pop  #ldata[t-5]
χ1d = kdata[t0] ./ statedf[statedf.year.==years[t0], :].pop #ldata[t]
S0d = Sdata[t0-5]

# time periods for NL solution
T = 300

# fundamentals path (no changes)
fundamentalshat_path = [[ones(N) for t = 1:T], [ones(N, N) for t = 1:T], [ones(N, N) for t = 1:T], [ones(N) for t = 1:T]]

# compute transition to implied t0 steady state
upath, lpath, wpath, phpath, χpath, Rpath, ςpath, Spath, Dpath = transition2sschangesCRRA(parameters, baseψ, fundamentalshat_path, l0d, l1d, χ0d, χ1d, D0d, S0d, damp=0.95, ctol=10^-6, innerctol=10^-5, displaygap=true)


# initial conditions from the implied steadystate
l0 = lpath[:, end-1]
D0 = Dpath[end-1]
l1 = D0' * l0
χ0 = χpath[:, end-1]
k0 = χ0 .* l0
χ1 = χpath[:, end-1]
S0 = Spath[end-1]

# plot entries of S and D matrices - data against implied steady-state
function simpleScatter(x, y)
        ols = lm(@formula(y ~ x), DataFrame(y=y, x=x))
        note = "Note: Slope coefficient: $(round(coef(ols)[2], digits=3)); standard error: $(round(stderror(ols)[2], digits=3)); R-squared: $(round(r2(ols), digits=3))"
        plt = Plots.scatter(x, y,
                #markersize=w,
                #color_palette=[:gray],
                markercolor=:navy,
                alpha=0.2,
                markeralpha=0.2,
                markerstrokecolor=:white,
                markerstrokealpha=0.0,
                #series_annotations=Plots.text.(stateabrv, 8, :black, 0.5),
                #group=stateregions,
                titlefont=9, legendfont=8, ytickfont=6, xtickfont=6, yguidefontsize=8, xguidefontsize=8,
                legend=:false,
                foreground_color_legend=nothing)
        Plots.abline!(coef(ols)[2], coef(ols)[1], line=:dash, color=:black, label="Linear fit")
        return plt, note
end

plt, note = simpleScatter(offd(S0d), offd(S0))
plot!(ylabel="Off-diagonal S matrix entries - 1975 implied steady state", xlabel="Off-diagonal S matrix entries - 1975 data \n \n $(note)", size=(500, 500))
Plots.savefig(plt, "figures/mats_dataVSss_S.pdf")
plt, note = simpleScatter(offd(D0d), offd(D0))
plot!(ylabel="Off-diagonal D matrix entries - 1975 implied steady state", xlabel="Off-diagonal D matrix entries - 1975 data \n \n $(note)", size=(500, 500))
Plots.savefig(plt, "figures/mats_dataVSss_D.pdf")

#=========================================================================================#
# Recover fundamentals for all years
#=========================================================================================#

# placeholders for levels
zvec = [zeros(N) for t = 1:length(years)-5]
bvec = [zeros(N) for t = 1:length(years)-5]
# placeholders for 5-year changes
zhatvec = [zeros(N) for t = 1:length(years)-5]
bhatvec = [zeros(N) for t = 1:length(years)-5]
for t = 6:length(years)
        println(years[t], " ", t)
        parameters = [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, baseγ]
        z, τ, κ, b = invertSymfundamentals(sharefunc(Ddata[t-5] .+ 10^-6), sharefunc(Ddata[t] .+ 10^-10), sharefunc(Sdata[t] .+ 10^-10), ldata[t], χdata[t], parameters, full=true)
        zvec[t-5] .= z ./ mean(z, weights(ldata[t]))
        bvec[t-5] .= b ./ mean(b, weights(ldata[t]))
        # vectors of changes
        if t >= 11
                zhatvec[t-5] = zvec[t-5] ./ zvec[t-10]
                bhatvec[t-5] = bvec[t-5] ./ bvec[t-10]
        end
end

#=========================================================================================#
# spectral decomposition
#=========================================================================================#

# compute matrices
P, R, A, B, Π, Ψ, Γ, H = Pmat(S0, D0, [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, baseγ], moreMatrices=true)
# using matrices from the data and not from steady-state
Pd, Rd = Pmat(Sdata[t0-5], Ddata[t0-5], [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, baseγ])
# normalization matrices
eyeN = diagm(ones(N));
zerosN = zeros(N, N);
auxnorm = [Qmat(D0) zeros(N, N); zeros(N, N) zeros(N, N)]
auxnormd = [Qmat(Ddata[t0-5]) zeros(N, N); zeros(N, N) zeros(N, N)]
# compute eigenshocks
F = (Π + auxnorm)^-1 * (Ψ * P + Ψ - Γ) * eigen((I - auxnorm) * P).vectors
# normalize eigenshocks
F = F .- [zeros(N); mean(F[N+1:2*N, :], dims=2)]
F = F ./ sum(abs.(F))
# compute P matrix and adjust to the capital-labor space
P = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * P * [(I-Qmat(D0)) zeros(N, N); -(I - Qmat(D0)) I]
#P = [I zeros(N, N); I I] * (I - auxnorm) * P * [I zeros(N, N); -I I]
# compute R matrix and adjust to the capital-labor space
R = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * R
# compute P and R (and adjust space) using the data matrices
Pd = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * Pd * [(I-Qmat(D0)) zeros(N, N); -(I - Qmat(D0)) I]
Rd = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * Rd

# spectral decomposition
U = eigen(P).vectors
V = U^-1
λ = eigen(P).values
Λ = diagm(λ)
#Fold = ([I zeros(N, N); I I] * Pmat(S0, D0, [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, baseγ])[2])^-1 * U
vals = -(log(2) ./ log.(real.(eigen(P).values[2:end])))
valsd = -(log(2) ./ log.(real.(eigen(Pd).values[2:end])))

# comprate half-lifes for P matrix in SS and in the data
plt = Plots.plot(5 * vals[1:end-1], color=:black, label="Trade and migration matrices from $(years[t0])")
plot!(5 * valsd[1:end-1], color=:crimson, line=:dash, label="Matrices from the implied $(years[t0]) steady-state")
xlabel!("Eigencomponent")
ylabel!("Halflife")
plot!(legend=:topleft, foreground_color_legend=nothing)
plot!(titlefont=9, legendfont=8, ytickfont=6, xtickfont=6, yguidefontsize=8, xguidefontsize=8)
# Plots.savefig(plt, "figures/datamats_VS_impliedSSmats.pdf")
Plots.savefig(plt, "figures/Figure_S_6_8.pdf")

# long-term shocks in the data
fdata = log.([zvec[end-2] ./ zvec[t0]; bvec[end-2] ./ bvec[t0]])


#=========================================================================================#
# Plot the full spectrum of eigenvalues in the data
#=========================================================================================#

pyplot()

hl = -(log(2) ./ log.(λ[2:end]));

kvalog(β, δ, μ) = 1 - μ * (1 - β * (1 - δ))
kval(β, δ, μ, ψ) = ((β + ψ * (1 - β) * (1 - kvalog(β, δ, μ)) + kvalog(β, δ, μ)) - ((β + ψ * (1 - β) * (1 - kvalog(β, δ, μ)) + kvalog(β, δ, μ))^2 - 4 * β * kvalog(β, δ, μ)) .^ 0.5) ./ (2 * β)

tempψ = 1.0

function plotspectrum()
        plt = Plots.plot(1:2*N, [0.0; 5 * hl], color=:black, label="", alpha=0.5)
        scatter!(1:2*N, [0.0; 5 * hl], color=:black, label="Halflives: -log(2)/log(λ)")
        vline!([1], label="Eigenvector (1,...,1,0,...,0) and eigenvalue 0 (instant convergence)", color=:crimson, line=:dot)
        vline!([N + 1], label="Eigenvector (0,...,0,1,...,1) and eigenvalue 1-μ(1-β(1-δ))", color=:navy)
        #hline!([0.0], color=:crimson, line=:dash, label="value=0")
        hline!([-5 * log(2) / log.(kval(baseβ, baseδ, baseμ, tempψ))], color=:navy, line=:dash, label="Halflife associated with eigenvalue 1-μ(1-β(1-δ))")
        plot!(size=(1000, 500))
        plot!(legend=:topleft, foreground_color_legend=nothing)
        plot!(titlefont=9, legendfont=8, ytickfont=8, xtickfont=8, yguidefontsize=8, xguidefontsize=8)
        xlabel!("Eigencomponent")
        ylabel!("Halflife")
        annotate!(25, 55, Plots.text("Components with negative K-L corr.", :black, 11))
        annotate!(75, 55, Plots.text("Components with positive K-L corr.", :black, 11))
        #savefig(plt, "figures/newfigs/spectrum.pdf")
end
#scatter([cor(U[N+1:end, i],U[1:N, i])*std(U[1:N, i])./std(U[N+1:end, i]) for i = 1:2*N])

# empirical loadings for 1965
datagaps = log.([l0d ./ l0; χ0d ./ χ0])
emploadings = U^-1 * datagaps
range = vec(2:2*N)#[vec(2:N); vec(N+2:2*N)]
emploadings = 400 * abs.(emploadings[range]) ./ sum(abs.(emploadings[range]))
plt = plotspectrum()
plot!(range, emploadings, line=:purple, alpha=1.0, label="")
scatter!(range, emploadings, marker=:square, color=:purple, alpha=1.0, label="Loadings of the $(years[t0]) gap from steady-state (scaled)")
Plots.savefig(plt, "figures/spectrum.pdf")

# empirical loadings for 1965-2015 shocks

L1 = F^-1 * fdata
L1 = 400 * abs.(L1[range]) ./ sum(abs.(L1[range]))
plot!(range, L1, line=:darkgreen, alpha=0.7, label="")
scatter!(range, L1, color=:darkgreen, marker=:diamond, alpha=0.7, label="Loadings of the $(years[t0])-2015 shocks (scaled)")
hline!([0.0], label="", color=:black)
Plots.savefig(plt, "figures/Figure_3.pdf")

#======================================================================#
# analysis of eigen-components
#======================================================================#

halflives = -5 * (log(2) ./ log.(real.(λ[1:end])))
eigenN = 2 * N

rng = [vec(2:N); vec(N+2:2*N)] # vec(2:2*N) #[vec(1:N-1); vec(N+1:2*N-1)]

# plot slopes
x = halflives[rng]
getslope(X, y) = (X' * X)^-1 * (X' * y)
plt = Plots.scatter([getslope([ones(N) U[N+1:end, i]], U[1:N, i])[2] for i in rng],
        x,
        color=:black,
        xlabel="Regression slope: L-SS-gap on K-SS-gap",
        ylabel="Half-life of eigen-component",
        legend=:false,
        foreground_color_legend=nothing,
        markerstrokewidth=0,
        alpha=0.3,
        markersize=5
)
vline!([0.0], line=(:dash, :black))
# Plots.savefig(plt, "figures/components_slopes.pdf")
Plots.savefig(plt, "figures/Figure_S_6_9.pdf")

# plot slopes in the shocks space
plt = Plots.scatter([getslope([ones(N) F[1:N, i]], F[N+1:end, i])[2] for i in rng],
        x,
        color=:black,
        xlabel="Regression slope: amenity shocks on productivity shocks",
        ylabel="Half-life of eigen-component",
        legend=:false,
        foreground_color_legend=nothing,
        markerstrokewidth=0,
        alpha=0.3,
        markersize=5
)
vline!([0.0], line=(:dash, :black))
# Plots.savefig(plt, "figures/component-shocks_slopes.pdf")
Plots.savefig(plt, "figures/Figure_S_6_10.pdf")

#======================================================================#
# plot halflives for different parameters
#======================================================================#

#year = 2000
t1 = findfirst(years .== 1975)
Neig = 2 * N - 1
Nlines = 10

function halflives_func(params::Vector, eis::Float64; onlylabor=false)

        Ptemp, Rtemp = Pmat(S0, D0, params, eis=eis)

        if !onlylabor
                Ptemp = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * Ptemp * [(I-Qmat(D0)) zeros(N, N); -(I - Qmat(D0)) I]
                Rtemp = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * Rtemp
        else
                Ptemp = (I - Qmat(D0)) * Ptemp
                Rtemp = (I - Qmat(D0)) * Rtemp

        end
        Λ = real(eigen(Ptemp).values)
        halflives = -5 * (log(2) ./ log.(real.(Λ[2:end])))
        return halflives
end

colorange = cgrad([:cornflowerblue, :coral3], Nlines).colors.colors;

### 6 plots with limiting labor share

ψrange = LinRange(0.5, 4.0, 10)
ρrange = LinRange(1.0, 5.0, 10)
βrange = LinRange(0.5, 0.9, 10)
θrange = LinRange(2.0, 20.0, 10)
μrange = LinRange(0.1, 0.99, 10)
γrange = LinRange(0.1, 0.9, 10)
δrange = LinRange(0.1, 0.9, 10)

hl_diffψ = [(halflives_func([baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, γdata[t1]], ψ)) for ψ in ψrange]
hl_diffρ = [(halflives_func([baseβ, ρ, baseθ, baseμ, baseξ, baseδ, γdata[t1]], 1.0)) for ρ in ρrange]
hl_diffβ = [(halflives_func([β, baseρ, baseθ, baseμ, baseξ, baseδ, γdata[t1]], 1.0)) for β in βrange]
hl_diffθ = [(halflives_func([baseβ, baseρ, θ, baseμ, baseξ, baseδ, γdata[t1]], 1.0)) for θ in θrange]
hl_diffμ = [(halflives_func([baseβ, baseρ, baseθ, μ, baseξ, baseδ, γdata[t1]], 1.0)) for μ in μrange]
hl_diffγ = [(halflives_func([baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, γ], 1.0)) for γ in γrange]
hl_diffδ = [(halflives_func([baseβ, baseρ, baseθ, baseμ, baseξ, δ, γdata[t1]], 1.0)) for δ in δrange]

plt1 = Plots.plot(hl_diffψ,
        color=permutedims([colorange[i] for i = 1:Nlines]),
        label=permutedims([["ψ=$(ψrange[1])"]; fill("", Nlines - 2); ["ψ=$(ψrange[end])"]]),
        title="EIS"
)
plt2 = Plots.plot(hl_diffρ,
        color=permutedims([colorange[i] for i = 1:Nlines]),
        label=permutedims([["ρ=$(ρrange[1])"]; fill("", Nlines - 2); ["ρ=$(ρrange[end])"]]),
        title="Migration elasticity"
)
plt3 = Plots.plot(hl_diffβ,
        color=permutedims([colorange[i] for i = 1:Nlines]),
        label=permutedims([["β=$(βrange[1])"]; fill("", Nlines - 2); ["β=$(βrange[end])"]]),
        title="Discount factor"
)
plt4 = Plots.plot(hl_diffμ,
        color=permutedims([colorange[i] for i = 1:Nlines]),
        label=permutedims([["μ=$(μrange[1])"]; fill("", Nlines - 2); ["μ=$(μrange[end])"]]),
        title="Labor share"
)
plot!((N+1):(2*N-1), (halflives_func([baseβ, baseρ, baseθ, 1.0, baseξ, baseδ, baseγ], 1.0, onlylabor=true)), label="No Capital", line=(:black, :dot, 2.0))
plt5 = Plots.plot(hl_diffθ,
        color=permutedims([colorange[i] for i = 1:Nlines]),
        label=permutedims([["θ=$(θrange[1])"]; fill("", Nlines - 2); ["θ=$(θrange[end])"]]),
        title="Trade elasticity"
)
plt6 = Plots.plot(hl_diffγ,
        color=permutedims([colorange[i] for i = 1:Nlines]),
        label=permutedims([["γ=$(γrange[1])"]; fill("", Nlines - 2); ["γ=$(γrange[end])"]]),
        title="Share of tradables"
)
plt = Plots.plot(plt1, plt2, plt3, plt4, plt5, plt6,
        legend=:topleft,
        foreground_color_legend=nothing,
        titlefont=8, legendfont=6, ytickfont=6, xtickfont=6, yguidefontsize=6, xguidefontsize=6,
        xlabel="Eigencomponent",
        ylabel="Half-life",
        alpha=0.5
)
# Plots.savefig(plt, "figures/halflifes_by_parameter_withnoK.pdf")
Plots.savefig(plt, "figures/Figure_7.pdf")

#=========================================================================================#
# Decompose the initial gaps
#=========================================================================================#

# compute eigencomponents
P, R = Pmat(S0, D0, [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, baseγ])
P = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * P * [(I-Qmat(D0)) zeros(N, N); -(I - Qmat(D0)) I]
R = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * R

# spectral decompositionrand(2,2)
U = eigen(P).vectors
V = U^-1
λ = eigen(P).values
Λ = diagm(λ)
vals = -(log(2) ./ log.(real.(eigen(P).values[2:end])))
valsd = -(log(2) ./ log.(real.(eigen(Pd).values[2:end])))

function statescatter(x, y; w=100 * ldata[t0] .^ 0.5)

        ### regression slope
        #X = [ones(length(x)) x]
        #b = (X'X)^-1 * X' * y
        ols = lm(@formula(y ~ x), DataFrame(y=y, x=x))
        note = "Note: Slope coefficient: $(round(coef(ols)[2], digits=3)); standard error: $(round(stderror(ols)[2], digits=3)); R-squared: $(round(r2(ols), digits=3))"

        #coef(ols)
        #stderror(temp)
        #r2(temp)


        plt = Plots.scatter(x, y,
                markersize=w,
                color_palette=[:cornflowerblue, :coral3, :gray, :crimson],
                markercolor=:match,
                markeralpha=0.6,
                markerstrokecolor=:white,
                markerstrokealpha=0.0,
                series_annotations=Plots.text.(stateabrv, 8, :black, 0.5),
                group=stateregions,
                titlefont=9, legendfont=8, ytickfont=6, xtickfont=6, yguidefontsize=8, xguidefontsize=8,
                legend=:topleft,
                foreground_color_legend=nothing)
        Plots.abline!(coef(ols)[2], coef(ols)[1], line=:dash, color=:black, label="Linear fit")
        return plt, note
end

# function to center labor around 0 using labor in the data for the plots
center0l(x::Vector) = x .- l0d' * x

# choose eigencomponent to split
spliti = 89

# plotting backend
pyplot()

datagaps = log.([l0d ./ l0; χ0d ./ χ0])
emploadings = U^-1 * datagaps
top_load_i = vec(1:98)
Usubset = hcat([(U[:, i]) for i in top_load_i]...) * emploadings[top_load_i]
auxnorm = [Qmat(D0) zeros(N, N); zeros(N, N) zeros(N, N)]
plt1, note = statescatter(center0l(Usubset[1:N]), Usubset[N+1:2*N])
plot!(ylabel="Capital gap from steady state", xlabel="Labor gap from steady state \n \n $(note)", size=(500, 500))
hline!([0], color=:gray, label="")
vline!([0], color=:gray, label="")
xlims!(-2.0, 1.7)
plot!(legend=:bottomright)
title!("Gaps from steady state in $(years[t0])")
Plots.savefig(plt1, "figures/$(years[t0])_gaps_components_1-98.pdf")

top_load_i = vec(spliti:98)
Usubset = hcat([U[:, i] for i in top_load_i]...) * emploadings[top_load_i]
plt2, note = statescatter(center0l(Usubset[1:N]), Usubset[N+1:2*N])
plot!(ylabel="Capital gap from steady state", xlabel="Labor gap from steady state \n \n $(note)", size=(500, 500))
hline!([0], color=:gray, label="")
vline!([0], color=:gray, label="")
xlims!(-2.0, 1.7)
plot!(legend=:false)
title!("Projection on the top 10 slowest-converging eigenvectors")
Plots.savefig(plt2, "figures/$(years[t0])_gaps_components_$(spliti)-98.pdf")

top_load_i = vec(1:(spliti-1))
Usubset = hcat([U[:, i] for i in top_load_i]...) * emploadings[top_load_i]
plt3, note = statescatter(center0l(Usubset[1:N]), Usubset[N+1:2*N])
plot!(ylabel="Capital gap from steady state", xlabel="Labor gap from steady state \n \n $(note)", size=(500, 500))
hline!([0], color=:gray, label="")
vline!([0], color=:gray, label="")
xlims!(-2.0, 1.7)
plot!(legend=:false)
title!("Projection on all other eigenvectors")
Plots.savefig(plt3, "figures/$(years[t0])_gaps_components_1-$(spliti-1).pdf")

plt = Plots.plot(plt1, plt2, plt3, layout=(1, 3), size=(1500, 500))
# Plots.savefig(plt, "figures/$(years[t0])_gaps_decomposition.pdf")
Plots.savefig(plt, "figures/Figure_4.pdf")

#=========================================================================================#
# Decompose the empirical shocks
#=========================================================================================#

emploadings = F^-1 * fdata #U^-1 * R * fdata
top_load_i = vec(1:98)
Fsubset = hcat([F[:, i] for i in top_load_i]...) * emploadings[top_load_i]
plt1, note = statescatter(Fsubset[1:N], center0l(Fsubset[N+1:2*N]))
plot!(ylabel="Amenity shocks", xlabel="Productivity shocks \n \n $(note)", size=(500, 500))
hline!([0], color=:gray, label="")
vline!([0], color=:gray, label="")
xlims!(-0.9, 1.5)
plot!(legend=:topright)
title!("Empirical shocks $(years[t0])-2015")
Plots.savefig(plt1, "figures/$(years[t0])_shocks_components_1-98.pdf")

top_load_i = vec(spliti:98)
Fsubset = hcat([F[:, i] for i in top_load_i]...) * emploadings[top_load_i]
plt2, note = statescatter(center0l(Fsubset[1:N]), Fsubset[N+1:2*N])
plot!(ylabel="Amenity shocks", xlabel="Productivity shocks \n \n $(note)", size=(500, 500))
hline!([0], color=:gray, label="")
vline!([0], color=:gray, label="")
xlims!(-0.9, 1.5)
plot!(legend=:false)
title!("Projection on the top 10 slowest-converging eigenshocks")
Plots.savefig(plt2, "figures/$(years[t0])_shocks_components_$(spliti)-98.pdf")

top_load_i = vec(1:(spliti-1))
Fsubset = hcat([F[:, i] for i in top_load_i]...) * emploadings[top_load_i]
plt3, note = statescatter(center0l(Fsubset[1:N]), Fsubset[N+1:2*N])
plot!(ylabel="Amenity shocks", xlabel="Productivity shocks \n \n $(note)", size=(500, 500))
hline!([0], color=:gray, label="")
vline!([0], color=:gray, label="")
xlims!(-0.9, 1.5)
plot!(legend=:false)
title!("Projection on all other eigenshocks")
Plots.savefig(plt3, "figures/$(years[t0])_shocks_components_1-$(spliti-1).pdf")

plt = Plots.plot(plt1, plt2, plt3, layout=(1, 3), size=(1500, 500))
# Plots.savefig(plt, "figures/$(years[t0])_shocks_decomposition.pdf")
Plots.savefig(plt, "figures/Figure_5.pdf")
#=========================================================================================#
# Plot linear transitions
#=========================================================================================#

T = 100
P_raw, R_raw, A, B, Π, Ψ, Γ, H = Pmat(S0, D0, [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, baseγ], moreMatrices=true, eis=1.0)
#P = (I - auxnorm) * P_raw
#R = (I - auxnorm) * R_raw
P = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * P_raw * [(I-Qmat(D0)) zeros(N, N); -(I - Qmat(D0)) I]
R = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * R_raw

U = eigen(P).vectors
V = U^-1
λ = eigen(P).values

# long-term shocks in the data
fdata = log.([zvec[end-2] ./ zvec[1]; bvec[end-2] ./ bvec[1]])

# define state groupings for MI and AZ
state1 = in(["MI",]).(stateabrv)
group1 = in(["OH", "IN", "IL", "WI"]).(stateabrv)
other1 = Bool.(ones(N) .- state1 .- group1)
state2 = in(["AZ",]).(stateabrv)
group2 = in(["CA", "NV", "UT", "CO", "NM"]).(stateabrv)
other2 = Bool.(ones(N) .- state2 .- group2)
other0 = Bool.(ones(N) .- state1 .- group1 .- state2 .- group2)

# function for fast plot cleanup
function plotclean()
        plot!(size=(500, 500))
        hline!([0.0], color=:black, line=:solid, label="")
        plot!(titlefont=10, legendfont=8, ytickfont=10, xtickfont=10, yguidefontsize=10, xguidefontsize=10)
        plot!(foreground_color_legend=nothing)
        ylabel!("Log. deviation from initial steady state")
        xlabel!("Time since shock")
end

# plotting function by sets of eigenvectors
function plotsubseteig(f̃, choseneigs, shock_st; pltrange=1:100)

        if shock_st == "MI"
                state = in(["MI",]).(stateabrv)
                group = in(["OH", "IN", "IL", "WI"]).(stateabrv)
                other = Bool.(ones(N) .- state .- group)
        elseif shock_st == "AZ"
                state = in(["AZ",]).(stateabrv)
                group = in(["CA", "NV", "UT", "CO", "NM"]).(stateabrv)
                other = Bool.(ones(N) .- state .- group)
        end

        markerrng = 5:10:length(pltrange)

        # full path
        xpath = zeros(2 * N, T)
        for t = 2:T
                #xpath[:, t] = (I - auxnorm) * (P * xpath[:, t-1] + R * f̃)
                xpath[:, t] = (P * xpath[:, t-1] + R * f̃)
        end
        lpath_approx = sharefunc(exp.(xpath[1:N, :]) .* l0, dims=1)
        #χpath_approx = exp.(xpath[N+1:end, :]) .* χ0
        #kpath_approx = χpath_approx .* lpath_approx
        kpath_approx = exp.(xpath[N+1:end, :]) .* (χ0 .* l0)

        # partial path
        loadings = V * R * f̃
        xtild_decomp = [((1 - λ[h]^t) / (1 - λ[h])) * U[:, h] * loadings[h] for h = 1:2*N, t = 1:T-1]

        shock_stid = stateabrv .== shock_st

        xtild_rec = hcat(sum(xtild_decomp[choseneigs, :], dims=1)...)
        lpath_rec = [l0 sharefunc(l0 .* exp.(xtild_rec[1:N, :]), dims=1)]
        χpath_rec = [χ0 χ0 .* exp.(xtild_rec[N+1:end, :])]
        kpath_rec = χpath_rec .* lpath_rec


        plt1 = Plots.plot(log.(lpath_approx[shock_stid, pltrange] ./ l0[shock_stid])', color=:black, alpha=0.8, label="$(shock_st) labor")
        if choseneigs != vec(1:98)
                plot!(log.(lpath_rec[shock_stid, pltrange] ./ l0[shock_stid])', color=:black, line=:dash, label="$(shock_st) L - eigenvectors $(choseneigs[1])-$(choseneigs[end])")
        end
        plotclean()
        plot!(legend=:outerbottom)

        plt2 = Plots.plot()

        # other states
        plot!(log.(lpath_approx[other, pltrange] ./ l0[other])', color=:gray, alpha=0.2, label="")

        # neighbours
        plot!(log.(lpath_approx[group, pltrange] ./ l0[group])', color=:navy, alpha=0.8, label="")
        scatter!(markerrng, log.((lpath_approx[group, pltrange] ./ l0[group])')[markerrng, :], marker=:o, markerstrokecolor=:navy, markerstrokealpha=0.8, markeralpha=0.0, label="")
        plot!([1], [0], color=:navy, marker=:o, markerstrokecolor=:navy, markerstrokealpha=0.8, markeralpha=0.0, alpha=0.8, label="$(shock_st) neighbours labor")
        #label=["MI neighbours labor" permutedims(fill("", sum(group1) - 1))]
        if choseneigs != vec(1:98)
                plot!(log.(lpath_rec[group, pltrange] ./ l0[group])', color=:navy, line=:dash, label="")
                scatter!(markerrng, log.((lpath_rec[group, pltrange] ./ l0[group])')[markerrng, :], marker=:o, markerstrokecolor=:navy, markerstrokealpha=0.5, markeralpha=0.0, label="")
                plot!([1], [0], line=:dash, color=:navy, marker=:o, markerstrokecolor=:navy, markerstrokealpha=0.5, markeralpha=0.0, alpha=0.8, label="$(shock_st) neighbours labor - eigenvectors $(choseneigs[1])-$(choseneigs[end])")
                #["MI neighbours L - eigenvectors $(choseneigs[1])-$(choseneigs[end])" permutedims(fill("", sum(group1) - 1))]
        end

        plot!([1], [0], color=:gray, alpha=0.2, label=["Other states labor" permutedims(fill("", sum(other) - 1))])

        plotclean()
        plot!(legend=:outerbottom)


        plt3 = Plots.plot(log.(kpath_approx[shock_stid, pltrange] ./ k0[shock_stid])', color=:black, alpha=0.8, label="$(shock_st) capital")
        if choseneigs != vec(1:98)
                plot!(log.(kpath_rec[shock_stid, pltrange] ./ k0[shock_stid])', color=:black, line=:dash, label="$(shock_st) K - eigenvectors $(choseneigs[1])-$(choseneigs[end])")
        end
        plotclean()
        plot!(legend=:outerbottom)

        plt4 = Plots.plot()

        # other states
        plot!(log.(kpath_approx[other, pltrange] ./ k0[other])', color=:gray, alpha=0.2, label="")

        # neighbours
        plot!(log.(kpath_approx[group, pltrange] ./ k0[group])', color=:navy, alpha=0.8, label="")
        scatter!(markerrng, log.((kpath_approx[group, pltrange] ./ k0[group])')[markerrng, :], marker=:o, markerstrokecolor=:navy, markerstrokealpha=0.8, markeralpha=0.0, label="")
        plot!([1], [0], color=:navy, marker=:o, markerstrokecolor=:navy, markerstrokealpha=0.8, markeralpha=0.0, alpha=0.8, label="$(shock_st) neighbours capital")
        #label=["MI neighbours labor" permutedims(fill("", sum(group1) - 1))]
        if choseneigs != vec(1:98)
                plot!(log.(kpath_rec[group, pltrange] ./ k0[group])', color=:navy, line=:dash, label="")
                scatter!(markerrng, log.((kpath_rec[group, pltrange] ./ k0[group])')[markerrng, :], marker=:o, markerstrokecolor=:navy, markerstrokealpha=0.5, markeralpha=0.0, label="")
                plot!([1], [0], line=:dash, color=:navy, marker=:o, markerstrokecolor=:navy, markerstrokealpha=0.5, markeralpha=0.0, alpha=0.8, label="$(shock_st) neighbours capital - eigenvectors $(choseneigs[1])-$(choseneigs[end])")
                #["MI neighbours L - eigenvectors $(choseneigs[1])-$(choseneigs[end])" permutedims(fill("", sum(group1) - 1))]
        end

        plot!([1], [0], color=:gray, alpha=0.2, label=["Other states capital" permutedims(fill("", sum(other) - 1))])

        plotclean()
        plot!(legend=:outerbottom)

        pltL, pltK = Plots.plot(plt1, plt2, size=(1000, 500), layout=(1, 2)), Plots.plot(plt3, plt4, size=(1000, 500), layout=(1, 2))

end

function genshock(state; z=true, scale=0.05)
        if z
                shock = scale * [Int.(stateabrv .== state); zeros(N)]
        else
                shock = scale * [zeros(N); Int.(stateabrv .== state)]
        end
        return shock
end

# choose eigencomponent to split
spliti = 89

pyplot()

choseneigs = vec(1:98)
pltL, pltK = plotsubseteig(genshock("MI", z=true, scale=fdata[21]), choseneigs, "MI")
Plots.savefig(pltL, "figures/Figure_6a.pdf")
Plots.savefig(pltK, "figures/Figure_S_6_11a.pdf")
pltL, pltK = plotsubseteig(genshock("AZ", z=false, scale=fdata[51]), choseneigs, "AZ")
Plots.savefig(pltL, "figures/Figure_S_6_12a.pdf")
Plots.savefig(pltK, "figures/Figure_S_6_13a.pdf")
choseneigs = vec(1:(spliti-1))
pltL, pltK = plotsubseteig(genshock("MI", z=true, scale=fdata[21]), choseneigs, "MI")
Plots.savefig(pltL, "figures/Figure_6b.pdf")
Plots.savefig(pltK, "figures/Figure_S_6_11b.pdf")
pltL, pltK = plotsubseteig(genshock("AZ", z=false, scale=fdata[51]), choseneigs, "AZ")
Plots.savefig(pltL, "figures/Figure_S_6_12b.pdf")
Plots.savefig(pltK, "figures/Figure_S_6_13b.pdf")
choseneigs = vec(spliti:98)
pltL, pltK = plotsubseteig(genshock("MI", z=true, scale=fdata[21]), choseneigs, "MI")
Plots.savefig(pltL, "figures/Figure_6c.pdf")
Plots.savefig(pltK, "figures/Figure_S_6_11c.pdf")
pltL, pltK = plotsubseteig(genshock("AZ", z=false, scale=fdata[51]), choseneigs, "AZ")
Plots.savefig(pltL, "figures/Figure_S_6_12c.pdf")
Plots.savefig(pltK, "figures/Figure_S_6_13c.pdf")

#=========================================================================================#
# Compute halflifes for 1975 convergence and 1975-2015 shocks
#=========================================================================================#


# compute matrices
P, R = Pmat(S0, D0, [baseβ, baseρ, baseθ, baseμ, baseξ, baseδ, baseγ])
P = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * P * [(I-Qmat(D0)) zeros(N, N); -(I - Qmat(D0)) I]
R = [(I-Qmat(D0)) zeros(N, N); (I-Qmat(D0)) I] * R
hl = -(log(2) ./ log.(real.(eigen(P).values[2:end])))
U = eigen(P).vectors

# empirical shocks
fdata = log.([zvec[end-2] ./ zvec[findfirst(years .== year0)]; bvec[end-2] ./ bvec[findfirst(years .== year0)]])

# loading weighted halflives
5 * [0.0; hl]' * sharefunc(abs.(F^-1 * fdata))
5 * [0.0; hl]' * sharefunc(abs.(U^-1 * [log.(l0d ./ l0); log.((χ0d .* l0d) ./ (χ0 .* l0))]))
```


